<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2100%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[PHP是世界上最好的语言]]></content>
  </entry>
  <entry>
    <title><![CDATA[外键概念及作用]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%A4%96%E9%94%AE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[现在假设我要建立一个班级的学生个人信息表 什么是外键？从表的某列引用主表的某列的值。在图中，表1是主表。表2是子表，但不是叫做给表1加入一个外键，而是给表2加入一个外键，表2中的学号字段就叫外键，它是表1学号字段的主键。 外键用来干什么？图片已经解释很清楚了。 为了一张表记录的数据不要太过冗余。这和软件project的模块化思想差点儿相同类似，仅仅只是在数据库中是对表关系进行解耦，尽量让表记录的数据单一化。就如图片中，把成绩和学生信息放在一张表中就太冗余了，成绩全然能够以学生的id作为区分标识。 为什么说外键能保持数据的一致性、完整性？试想，如果图中的第一张表切割成了表1和表2，表2的学号仅仅是和表1一样单纯性地设立一个学号字段。那么这和建立外键有什么差别呢？ 比方表1中张三的学号为20140900000，那么我在表2中插数据的时候在学号字段插20140900000来记录张三的成绩不也是做到了表 的解耦了吗？ 这里存在的问题是。在不设置外键的情况下。表2的学号字段和表1的学号字段是没有关联的。仅仅是你自己觉得他们有关系而已。数据库并不觉得它俩有关系。也就是说，你在表2的学号字段插了一个值（比方20140999999），可是这个值在表1中并没有，这个时候，数据库还是允许你插入的，它并不会对插入的数据做关系检查。然而在设置外键的情况下。你插入表2学号字段的值必需要求在表1的学号字段能找到。同一时候。假设你要删除表1的某个学号字段。必须保证表2中没有引用该字段值的列，否则就没法删除。 这就是所谓的保持数据的一致性和完整性。试想。如果表2还引用表1的某个学号，你却把表1中的这个学号删了，表2就不知道这个学号对应的是哪个学生了。 数据的一致性还包含数据类型的一致性（这 个见以下就知道了）。 外键的使用规范 从表的字段必须与外键类型同样（如上。分数表 stu 的类型必须和学生表 sid 的类型同样，比方都是 int(10) 类型） 外键必须是主表的唯一键（如上。学生表 sid 是主键，而主键是唯一的。所以能够作为分数表 stu 的外键） 有关联的字段（如上，分数表之所以使用学生表的 sid 是由于两者有关联，分数表记录的是学生的分数，而学生能够用 sid 来唯 一标识） 避免使用复合键（也就是说从表能够同一时候引用多个外表的字段作为一个外键，一般不推荐这样的做法）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcache]]></title>
    <url>%2F2018%2F02%2F14%2FMemcache%2F</url>
    <content type="text"><![CDATA[在Mac环境下安装memcache 没 brew 安装brew brew安装完成后，执行以下命令：brew insatall memcached 123456789101112131415161718Updating Homebrew...==&gt; Installing dependencies for memcached:libevent==&gt; Installing memcached dependency:libevent==&gt; Downloading https://homebrew.bintray.com/bottles/libevent-2.0.22.sierra.bott######################################################################## 100.0%==&gt; Pouring libevent-2.0.22.sierra.bottle.1.tar.gz�� /usr/local/Cellar/libevent/2.0.22: 734 files, 2.0M==&gt; Installing memcached ==&gt; Downloading https://homebrew.bintray.com/bottles/memcached-1.4.33.sierra.bot######################################################################## 100.0%==&gt; Pouring memcached-1.4.33.sierra.bottle.tar.gz==&gt; CaveatsTo have launchd start memcached now and restart at login: brew services start memcachedOr, if you don&apos;t want/need a background service you can just run: /usr/local/opt/memcached/bin/memcached==&gt; Summary�� /usr/local/Cellar/memcached/1.4.33: 11 files, 184.5K 启动停止命令： 123brew services start memcachedbrew services stop memcached 安装客户端：brew install libmemcached 1234==&gt; Downloading https://homebrew.bintray.com/bottles/libmemcached-1.0.18_1.sierr######################################################################## 100.0%==&gt; Pouring libmemcached-1.0.18_1.sierra.bottle.tar.gz� /usr/local/Cellar/libmemcached/1.0.18_1: 230 files, 1.8M 设置启动，守护线程 内存 ip端口：memcached -p 11211 -m 2048 -u root -d 测试连接：telnet localhost 11211 123Trying 127.0.0.1...Connected to bogon.Escape character is &apos;^]&apos;. 按Ctrl + ] 会呼出telnet的命令行，出来telnet命令好之后就可以执行telnet命令 memcached的命令分为 增删改查4类，沿着这个思路来学习 增：add往内存增加一行新纪录1语法：add key flag expire length 用add时，如果内存中已经有这个键，就无法再使用add进行添加，但是可以使用replace进行替换/更改 key：给值取一个独特的名字 flag：标志，要求为一个正整数 expire：有效期 length：缓存的长度（字节为单位） flag的意义：memcache基本文本协议，传输的东西，理解成字符串来存储 question：想存一个PHP对象和一个PHP数组怎么办？answer：序列化成字符串，往外取得时候，自然还要反序列成对象/数组/json/格式等等，这是flag的意义就体现出来了 expire的意义：设置缓存的有效期，有3种格式 设置秒数，从设定开始数，第N秒后失效 时间戳，到指定事件戳后失效，（适用于团购活动倒计时等场景） 设置为0，不自动失效（不是永不失效，如服务器重启或者老数据被挤出，都会导致数据失效，即便什么都没发生，30天后也会失效） 删：删除内存中的一行记录1语法：delete key [time seconds] 中括号里面的秒数是可选参数，加上之后是指，被删除的key，N秒内不能再用，目的是让网站上的页面缓存也代谢完毕 替换：替换内存中的一行记录1语法：replace key flag expire length 参数与add完全一样，不再赘述 只有key值存在时，才能修改键值， 查询：查询一条记录1语法：get key 返回key值 set 是设置和修改值：相当于有set和replace两者的功能1语法：set key flag expire length 如果服务器无此键 ——&gt; 增加的效果 如果服务器有此键 ——&gt; 修改的效果 incr、decr命令：增加或减少值的大小（适用于抢购等场景）123incr key numdecr key num 示例：incr age 2 //年龄增加2岁需要注意的是，这两个命令是把值当做32位无符号来操作的，也就是说，值最小是0，不会出现负数 stats：统计命令flush_all命令：清空所有存储对象memcache内存分配机制内存的碎片化?如果用C语言直接malloc，free来向操作系统申请和释放内存时，在不断的申请和释放过程中，形成了一些很小的内存碎片，无法再利用，这种空闲，但无法利用内存的现象，称为内存的碎片化 memcache是如何缓解内存碎片化的？memcache用slab allocator机制来管理内存 基本原理：预先把内存分成数个slab仓库，各仓库，切分成不同尺寸的小块，需要存入内容时，判断内容的大小，为其选择合理的仓库 需要注意的是，如果有100byte的内容要存，但122大小的仓库中的chunk满了，并不会寻找更大的仓库，如144的仓库来存储，而是把122仓库的旧数据踢掉。详见过期与删除机制 对于固定大小的chunk，也会有浪费，如何缓解？对于特定的网站，可以长期统计网站内的缓存数据，根据自己网站的特点，设置chunk的大小 一般而言，观察缓数据大小的变化规律，设置合理的生长因子,grow factor默认是1.25倍，可以使用 -f num根据网站缓存的大小进行设置 memcache的过期数据删除机制 当某个值过期后，并没有从内存中删除，因此，stats统计时，curr_item仍有其信息 当某个新值去占用他的位置时，当成chunk来占用 当get值时，判断是否过期，如果过期，返回空，并且清空，curr_item就减少了 即这个过期数据只是让用户看不到而已，并没有在过期的瞬间立即从内存删除，这个称谓lazy expiration，惰性失效 如果chunk都满了，又有新的值要加入，要挤掉谁？memcache此处用的是LRU删除机制 操作系统的内存管理： FIFO：先进先出 LRU：最近最少使用：当某个单元被请求时，维护一个计数器，通过计数器来判断，最近谁最少被使用，就把谁踢出 memcache中的参数限制 key的长度：250字节，（二级制协议支持6535个字节） value的限制：1M，一般都是存储一些文本，如新闻列表等等，这个值足够了 内存的限制：32位下最大设置到2G，64位基本不需要考虑 如果有30G数据要缓存，一般也不会单实例装30G，（不要把鸡蛋放在一个篮子），一般建议，开启多个实例（可以再不同的机器，或同台机器上的不同端口） PHP连接memcache 下载memcached.dll，并放在php/ext目录下，下载是需要考虑3个条件（在phpinfo()中查看），PHP版本/ts或nts/vc6还是vc9 观察正确的目录和配置文件路径，并观察extension_dir的路径，先运行phpinfo()，确认真正使用的php.ini是哪一个 把dll放入extension目录，并修改php.ini，引入dll 一致性哈希分布式1. 余数Hash假设现在通过相关计算，可以算得某字符串str的hashcode,同时现在又有3台服务器，利用余数hash便可以算得该字符串应该存储在哪台服务器上 1234560 % 3 ~ 01 % 3 ~ 12 % 3 ~ 23 % 3 ~ 04 % 3 ~ 15 % 3 ~ 2 HashCode 0 1 2 3 4 5 6 7 8 9 路由到的服务器 0 1 2 0 1 2 0 1 2 0 假设我现在将服务器扩充到了4台，就会出现如下变化 HashCode 0 1 2 3 4 5 6 7 8 9 路由到的服务器 0 1 2 3 0 1 2 3 0 1 数据由原来100%的命中率，下降为30%，这个结果显然是无法接受的，在网站业务中，大部分的业务数据的操作请求上事实上是通过缓存获取的，只有少量读操作会访问数据库，因此数据库的负载能力是以有缓存为前提而设计的。当大部分被缓存了的数据因为服务器扩容而不能正确读取时，这些数据访问的压力就落在了数据库的身上，这将大大超过数据库的负载能力，严重的可能会导致数据库宕机。 这个问题有解决方案，解决步骤为： 在网站访问量低谷，通常是深夜，技术团队加班，扩容、重启服务器 通过模拟请求的方式逐渐预热缓存，使缓存服务器中的数据重新分布 1. 一致性Hash一致性Hash算法通过一个叫做一致性Hash环的数据结构实现Key到缓存服务器的Hash映射，看一下我自己画的一张图： 具体算法过程为：先构造一个长度为2^32^的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 2^32^-1]）将缓存服务器节点放置在这个Hash环上，然后根据需要缓存的数据的Key值计算得到其Hash值（其分布也为[0, 2^32^-1]），然后在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。 就如同图上所示，三个Node点分别位于Hash环上的三个位置，然后Key值根据其HashCode，在Hash环上有一个固定位置，位置固定下之后，Key就会顺时针去寻找离它最近的一个Node，把数据存储在这个Node的MemCache服务器中。使用Hash环如果加了一个节点会怎么样，看一下： 看到我加了一个Node4节点，只影响到了一个Key值的数据，本来这个Key值应该是在Node1服务器上的，现在要去Node4了。采用一致性Hash算法，的确也会影响到整个集群，但是影响的只是加粗的那一段而已，相比余数Hash算法影响了远超一半的影响率，这种影响要小得多。更重要的是，集群中缓存服务器节点越多，增加节点带来的影响越小，很好理解。换句话说，随着集群规模的增大，继续命中原有缓存数据的概率会越来越大，虽然仍然有小部分数据缓存在服务器中不能被读到，但是这个比例足够小，即使访问数据库，也不会对数据库造成致命的负载压力。 至于具体应用，这个长度为2^32^的一致性Hash环通常使用二叉查找树实现，至于二叉查找树，就是算法的问题了，可以自己去查询相关资料。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Memcache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX实现负载均衡的几种方式]]></title>
    <url>%2F2017%2F06%2F22%2FNGINX%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[要理解负载均衡，必须先搞清楚正向代理和反向代理。 正向代理，代理的是用户。 反向代理，代理的是服务器 正向代理正向代理类似一个跳板机，代理访问外部资源。 举个例子: 我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。 客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。 总结来说： 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 正向代理的用途： 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理初次接触反向代理的感觉是，客户端是无感知代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。 反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 反向代理的作用： 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。 负载均衡，通过反向代理服务器来优化网站的负载 二者区别 nginx的反向代理nginx支持配置反向代理，通过反向代理实现网站的负载均衡。这部分先写一个nginx的配置，后续需要深入研究nginx的代理模块和负载均衡模块。 nginx通过proxy_pass_http 配置代理站点，upstream实现负载均衡。 什么是负载均衡当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。 我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个中间服务器，在让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该服务器。如此以来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。 负载均衡是用反向代理的原理实现的。 负载均衡的几种常用方式 轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 1234upstream backserver &#123; server 192.168.0.14; server 192.168.0.15;&#125; weight：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 1234upstream backserver &#123; server 192.168.0.14 weight=3; server 192.168.0.15 weight=7;&#125; 权重越高，在被访问的概率越大，如上例，分别是30%，70%。 ip_hash：上述方式存在一个问题就是说，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。 我们可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 12345upstream backserver &#123; ip_hash; server 192.168.0.14:88; server 192.168.0.15:80;&#125; fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream backserver &#123; server server1; server server2; fair;&#125; url_hash（第三方）按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 123456upstream backserver &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32;&#125; 每个设备的状态设置为: down 表示单前的server暂时不参与负载 weight 默认为1.weight越大，负载的权重就越大。 max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 fail_timeout:max_fails次失败后，暂停的时间。 backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 配置实例： 1234567891011121314151617181920212223242526#user nobody;worker_processes 4;events &#123; # 最大并发数 worker_connections 1024;&#125;http&#123; # 待选服务器列表 upstream myproject&#123; # ip_hash指令，将同一用户引入同一服务器。 ip_hash; server 125.219.42.4 fail_timeout=60s; server 172.31.2.183; &#125; server&#123; # 监听端口 listen 80; # 根目录下 location / &#123; # 选择哪个服务器列表 proxy_pass http://myproject; &#125; &#125;&#125; 负载均衡引发的问题多台机器间session的共享问题配置负载均衡比较简单,但是最关键的一个问题是怎么实现多台服务器之间session的共享，下面有几种方法： 不使用session，换作cookie能把session改成cookie，就能避开session的一些弊端，在从前看的一本J2EE的书上，也指明在集群系统中不能用session，否则惹出祸端来就不好办。如果系统不复杂，就优先考虑能否将session去掉，改动起来非常麻烦的话，再用下面的办法。 应用服务器自行实现共享 php可以用数据库或memcached来保存session，从而在php本身建立了一个session集群，用这样的方式可以令 session保证稳定，即使某个节点有故障，session也不会丢失，适用于较为严格但请求量不高的场合。但是它的效率是不会很高的，不适用于对效率要求高的场合。 以上两个办法都跟nginx没什么关系，下面来说说用nginx该如何处理： ip_hash：nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip_hash是在upstream配置中定义的： 12345upstream backend &#123; server 127.0.0.1:8080 ; server 127.0.0.1:9090 ; ip_hash;&#125; ip_hash是容易理解的，但是因为仅仅能用ip这个因子来分配后端，因此ip_hash是有缺陷的，不能在一些情况下使用： nginx不是最前端的服务器。ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。 nginx的后端还有其它方式的负载均衡。假如nginx后端又有其它负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台session应用服务器上。这么算起来，nginx后端只能直接指向应用服务器，或者再搭一个squid，然后指向应用服务器。最好的办法是用location作一次分流，将需要session的部分请求通过ip_hash分流，剩下的走其它后端去。 upstream_hash 为了解决ip_hash的一些问题，可以使用upstream_hash这个第三方模块，这个模块多数情况下是用作url_hash的，但是并不妨碍将它用来做session共享。假如前端是squid，他会将ip加入x_forwarded_for这个http_header里，用upstream_hash可以用这个头做因子，将请求定向到指定的后端 后端服务器自动加上端口的问题一个典型的 Nginx + Apache 应用方案可以是Nginx 占用 80 端口，过滤静态请求，然后动态请求即 Proxy 到 Apache 的 8080 端口。Proxy 反向代理的好处是访问的时候，始终就是 80端口，来访者不会觉察到有任何的区别。但有的应用确非常“聪明”，识别到 Apache 所位于的端口是 8080 ，就会把相关的超链接都一并加上 :8080 的后续。这么就死定了，还能有正常访问麽？！有个方法可以解决这事，就是把 apache 也运行在80端口上。同一台服务器，有Nginx 也有 Apache，2个httpd服务，都是80，不会冲突麽？ nginx.conf 的配置文件 12345server &#123; listen 80; server_name www.linuxidc.com; ....&#125; 修改文 123456server &#123; listen 123.123.123.123:80; #指定Nginx只占用某个公网IP的80端口。 #listen 123.123.123.124:80; #如果你服务器中有多个IP，还可以指定多个。 server_name www.linuxidc.com;....&#125; 把 apache 的配置文件 httpd.conf 中的Listen 80 改为Listen 127.0.0.1:80 跟Nginx一样，指定apache所占用的IP及端口。保存退出，重启apache即可生效。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令]]></title>
    <url>%2F2016%2F08%2F05%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用指令1ls 显示文件或目录 -l：列出文件详细信息l(list) -a：列出当前目录下所有文件及目录，包括隐藏的a(all) 1mkdir 创建目录 -p 创建目录，若无父目录，则创建p(parent) 1cd 切换目录 1touch 创建空文件 1echo 创建带有内容的文件。 1cat 查看文件内容 1cp 拷贝 1mv 移动或重命名 1rm 删除文件 -r 递归删除，可删除子目录及文件 -f 强制删除 1find 在文件系统中搜索某文件 1wc 统计文本中行数、字数、字符数 1grep 在文本文件中查找某个字符串 1rmdir 删除空目录 1tree 树形结构显示目录，需要安装tree包 1pwd 显示当前目录 1ln 创建链接文件 1more、less 分页显示文本文件内容 1head、tail 显示文件头、尾内容 1ctrl+alt+F1 命令行全屏模式 系统管理命令1stat 显示指定文件的详细信息，比ls更详细 1who 显示在线登陆用户 1whoami 显示当前操作用户 1hostname 显示主机名 1uname 显示系统信息 1top 动态显示当前耗费资源最多进程信息 1ps 显示瞬间进程状态 ps - -aux 1du 查看目录大小 du -h /home带有单位显示目录信息 1df 查看磁盘大小 df -h 带有单位显示磁盘信息 1ifconfig 查看网络情况 1ping 测试网络连通 1netstat 显示网络状态信息 1man 命令不会用了，找男人 如：man ls 1clear 清屏 1alias 对命令重命名 如：alias showmeit=&quot;ps -aux&quot; ，另外解除使用unaliax showmeit 1kill 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。 打包压缩相关命令1- gzip： 1- bzip2： 1- tar: 打包压缩 -c 归档文件 -x 压缩文件 -z gzip压缩文件 -j bzip2压缩文件 -v 显示压缩或解压缩过程 v(view) -f 使用档名 例： tar -cvf /home/abc.tar /home/abc 只打包，不压缩 tar -zcvf /home/abc.tar.gz /home/abc 打包，并用gzip压缩 tar -jcvf /home/abc.tar.bz2 /home/abc 打包，并用bzip2压缩 当然，如果想解压缩，就直接替换上面的命令 tar -cvf / tar -zcvf / tar -jcvf 中的“c” 换成“x” 就可以了。 tar –zxvf apache-maven-3.3.3.tar.gz 关机/重启机器1shutdown -r 关机重启 -h 关机不重启 now 立刻关机 1halt 关机 1reboot 重启 Linux管道将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。 例：grep -r “close” /home/* | more 在home目录下所有文件中查找，包括close的文件，并分页输出。 Linux软件包管理 dpkg (Debian Package)管理工具，软件包名以.deb后缀。这种方法适合系统不能联网的情况下。 比如安装tree命令的安装包，先将tree.deb传到Linux系统中。再使用如下命令安装。123sudo dpkg -i tree_1.5.3-1_i386.deb 安装软件sudo dpkg -r tree 卸载软件 注：将tree.deb传到Linux系统中，有多种方式。VMwareTool，使用挂载方式；使用winSCP工具等； APT（Advanced Packaging Tool）高级软件工具。这种方法适合系统能够连接互联网的情况。 依然以tree为例1234sudo apt-get install tree 安装treesudo apt-get remove tree 卸载treesudo apt-get update 更新软件sudo apt-get upgrade 将.rpm文件转为.deb文件.rpm为RedHat使用的软件格式。在Ubuntu下不能直接使用，所以需要转换一下。sudo alien abc.rpm vim使用vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。 命令模式下： 12345678:q 退出:q! 强制退出:wq 保存并退出:set number 显示行号:set nonumber 隐藏行号/apache 在文档中查找apache 按n跳到下一个，shift+n上一个yyp 复制光标所在行，并粘贴h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→) 用户及用户组管理1234567891011121314151617/etc/passwd 存储用户账号/etc/group 存储组账号/etc/shadow 存储用户账号的密码/etc/gshadow 存储用户组账号的密码useradd 用户名userdel 用户名adduser 用户名groupadd 组名groupdel 组名passwd root 给root设置密码su rootsu - root /etc/profile 系统环境变量bash_profile 用户环境变量.bashrc 用户环境变量su user 切换用户，加载配置文件.bashrcsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profile 更改文件的用户及用户组1234567sudo chown [-R] owner[:group] &#123;File|Directory&#125;例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop要想切换此文件所属的用户及组。可以使用命令。sudo chown root:root jdk-7u21-linux-i586.tar.gz 文件权限管理三种基本权限12345R 读 数值表示为4W 写 数值表示为2X 可执行 数值表示为1 1234567891011-rw-rw-r--一共十个字符，分成四段。第一个字符“-”表示普通文件；这个位置还可能会出现“l”链接；“d”表示目录第二三四个字符“rw-”表示当前所属用户的权限。 所以用数值表示为4+2=6第五六七个字符“rw-”表示当前所属组的权限。 所以用数值表示为4+2=6第八九十个字符“r--”表示其他用户权限。 所以用数值表示为2所以操作此文件的权限用数值表示为662 1234567891011更改权限sudo chmod [u所属用户 g所属组 o其他用户 a所有用户] [+增加权限 -减少权限] [r w x] 目录名 例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为&quot;-rwxrw-r-x&quot;，用数值表示为765sudo chmod u+x g+w o+r filename上面的例子可以用数值表示sudo chmod 765 filename]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础（二）]]></title>
    <url>%2F2016%2F01%2F14%2FRedis%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Redis中的事务(transaction)是一组命令的集合。事务同命令一样都是Redis 的最小执行单位，一个事务中的命令要么都执行，要么都不执行。 123456789redis&gt; MULTIOKredis&gt; SADD &quot;user:1:following&quot; 2QUEUEDredis&gt; SADD &quot;user:2:followers&quot; 1QUEUEDredis&gt; EXEC1) (integer) 12) (integer) 1 Redis 的事务还能保证一个事务内的命令依次执行而不被其他命令插入。试想客户端A需要执行几条命令，同时客户端B发送了一条命令，如果不使用事务，则客户端B的命令可能会插入到客户端A的几条命令中执行。 Redis事务错误处理 语法错误 12345678910redis&gt; MULTIOKredis&gt; SET key valueQUEUEDredis&gt; SET key(error) ERR wrong number of arguments for &apos;set&apos; commandredis&gt; ERRORCOMMAND key(error) ERR unknown command &apos;ERRORCOMMAND&apos;redis&gt; EXEC(error) EXECABORT Transaction discarded because of previous errors. 只要有一个命令有语法错误，执行 EXEC 命令后 Redis就会直接返回错误，连语法正确的命令也不会执行。 运行错误 1234567891011121314redis&gt; MULTIOKredis&gt; SET key 1QUEUEDredis&gt; SADD key 2QUEUEDredis&gt; SET key 3QUEUEDredis&gt; EXEC1) OK2) (error) WRONGTYPE Operation against a key holding the wrong kind of value3) OKredis&gt; GET key&quot;3&quot; 运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前 Redis 是无法发现的，所以在事务里这样的命令是会被 Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令） Redis的事务没有关系数据库事务提供的回滚（rollback）功能。 watch命令介绍watch 命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到 EXEC 命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值） 1234567891011121314redis&gt; SET key 1OKredis&gt; WATCH keyOKredis&gt; SET key 2OKredis&gt; MULTIOKredis&gt; SET key 3QUEUEDredis&gt; EXEC(nil)redis&gt; GET key&quot;2&quot; 过期时间12345expire [key] [seconds] //指定秒数后过期ttl [key] //查看一个键的剩余存活时间persist [key] //将键恢复成永久 除了PERSIST命令之外，使用SET或GETSET命令为键赋值也会同时清除键的过期时间 如果使用 WATCH命令监测了一个拥有过期时间的键，该键时间到期自动删除并不会被WATCH命令认为该键被改变。 expire会重新设置键的过期时间 12345678910redis&gt; SET foo barOKredis&gt; EXPIRE foo 20(integer) 1redis&gt; TTL foo(integer) 15redis&gt; EXPIRE foo 20(integer) 1redis&gt; TTL foo(integer) 17 如果想要更精确的控制键的过期时间应该使用 pexpire命令，其时间单位是毫秒，对应地可以用PTTL命令以毫秒为单位返回键的剩余时间 实现缓存1234567$rank = GET cache:rankif not $rank$rank = 计算排名...MUlTISET cache:rank, $rankEXPIRE cache:rank, 7200EXEC 排序SORT命令可以对列表类型、集合类型和有序集合类型键进行排序，并且可以完成与关系数据库中的连接查询相类似的任务。 1sort [key] 在对有序集合类型排序时会忽略元素的分数，只针对元素自身的值进行排序 除了可以排列数字外，SORT命令还可以通过ALPHA参数实现按照字典顺序排列非数字元素 123456789101112redis&gt; LPUSH mylistalpha a c e d B C A(integer) 7redis&gt; SORT mylistalpha(error) ERR One or more scores can&apos;t be converted into doubleredis&gt; SORT mylistalpha ALPHA1) &quot;A&quot;2) &quot;B&quot;3) &quot;C&quot;4) &quot;a&quot;5) &quot;c&quot;6) &quot;d&quot;7) &quot;e” 倒序排序 1sort [key] desc 返回指定范围的排序结果 1sort [key] limit (start)num (end)num by参数如果提供了 BY 参数，SORT 命令将不再依据元素自身的值进行排序，而是对每个元素使用元素的值替换参考键中的第一个“*”并获取其值，然后依据该值对元素排序。 12345redis&gt; SORT tag:ruby:posts BY post:*-&gt;time DESC1) &quot;12&quot;2) &quot;26&quot;3) &quot;6&quot;4) &quot;2&quot; 除了散列类型之外，参考键还可以是字符串类型 当参考键名不包含“*”时（即常量键名，与元素值无关），SORT命令将不会执行排序操作 1234redis&gt; SORT sortbylist BY itemscore:* DESC1) &quot;2&quot;2) &quot;1&quot;3) &quot;3&quot; get参数GET参数不影响排序，它的作用是使 SORT命令的返回结果不再是元素自身的值，而是GET参数中指定的键值。 12345redis&gt; SORT tag:ruby:posts BY post:*-&gt;time DESC GET post:*-&gt;title1) &quot;Windows 8 app designs&quot;2) &quot;RethinkDB - An open-source distributed database built with love&quot;3) &quot;Uses for cURL&quot;4) &quot;The Nature of Ruby&quot; 在一个SORT命令中可以有多个GET参数（而BY参数只能有一个） 123456789redis&gt; SORT tag:ruby:posts BY post:*-&gt;time DESC GET post:*-&gt;title GET post:*-&gt;time1) &quot;Windows 8 app designs&quot;2) &quot;1352620100&quot;3) &quot;RethinkDB - An open-source distributed database built with love&quot;4) &quot;1352620000&quot;5) &quot;Uses for cURL&quot;6) &quot;1352619600&quot;7) &quot;The Nature of Ruby&quot;8) &quot;1352619200&quot; GET #会返回元素本身的值 store参数默认情况下SORT会直接返回排序结果，如果希望保存排序结果，可以使用store参数 1234567891011121314151617//把结果保存到sort.result键中redis&gt; SORT tag:ruby:posts BY post:*-&gt;time DESC GET post:*-&gt;title GET post:*-&gt;time GET # STORE sort.result(integer) 12redis&gt; LRANGE sort.result 0 -11) &quot;Windows 8 app designs&quot;2) &quot;1352620100&quot;3) &quot;12&quot;4) &quot;RethinkDB - An open-source distributed database built with love&quot;5) &quot;1352620000&quot;6) &quot;26&quot;7) &quot;Uses for cURL&quot;8) &quot;1352619600&quot;9) &quot;6&quot;10) &quot;The Nature of Ruby&quot;11) &quot;1352619200&quot;12) &quot;2&quot; 性能优化 SORT命令的时间复杂度是O(n+mlog(m)) 尽可能减少待排序键中元素的数量（使N尽可能小）。 使用LIMIT参数只获取需要的数据（使M尽可能小）。 如果要排序的数据数量较大，尽可能使用STORE参数将结果缓存。 任务队列为了测试实现对列，我们可以打开两个redis-cli实例，进行演示 在redis-cli[A]中进行如下操作 123redis A&gt; BRPOP queue 0//键入回车后会处于阻塞状态 在redis-cli[B]中进行如操作 12redis B&gt; LPUSH queue task(integer) 1 在LPUSH命令执行后redis-cli[A]马上就返回了结果 1234561) &quot;queue&quot;2) &quot;task&quot;//同时会发现redis-cli[B]中queue的元素已经被取走：redis&gt; LLEN queue(integer) 0 优先级队列例如打开两个 redis-cli 实例，在实例A中：1redis A&gt; BLPOP queue:1 queue:2 queue:3 0 在实例B中：12redis B&gt; LPUSH queue:2 task(integer) 1 则实例A中会返回：121) &quot;queue:2&quot;2) &quot;task&quot; 如果多个键都有元素则按照从左到右的顺序取第一个键中的一个元素。我们先在queue:2和queue:3中各加入一个元素：12345678redis&gt; LPUSH queue:2 task11) (integer) 1redis&gt; LPUSH queue:3 task22) (integer) 1然后执行BRPOP命令：redis&gt; BRPOP queue:1 queue:2 queue:3 01) &quot;queue:2&quot;2) &quot;task1&quot; “发布/订阅”模式发布/订阅”模式中包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或若干个频道（channel），而发布者可以向指定的频道发送消息，所有订阅此频道的订阅者都会收到此消息。 发布者发布消息的命令是 PUBLISH 123redis&gt; PUBLISH channel.1 hi(integer) 0//向channel.1频道发布内容为“hi”的信息，返回值为0，表示没有订阅者收到消息（因为此时并没有用户订阅该频道） 订阅频道的命令是 SUBSCRIBE“现在新开一个redis-cli 实例 A，用它来订阅 channel.1： 12345redis A&gt; SUBSCRIBE channel.1Reading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;channel.1&quot;3) (integer) 1 执行 SUBSCRIBE 命令后客户端会进入订阅状态，处于此状态下客户端不能使用除SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE这4个之外的命令，否则会报错。 subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个值是当前客户端订阅的频道数量。 message。这个类型的回复是我们最关心的，它表示接收到的消息。第二个值表示产生消息的频道名称，第三个值是消息的内容。 unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非“发布/订阅”模式的命令了。 这时我们打开另一个redis-cli实例B，并向channel.1发送一条消息： 123redis B&gt; PUBLISH channel.1 hi!(integer) 1返回值为1表示有一个客户端订阅了channel.1， 此时实例A收到了类型为message的回复：1231) &quot;message&quot;2) &quot;channel.1&quot;3) &quot;hi!&quot;]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础（一）]]></title>
    <url>%2F2016%2F01%2F12%2FRedis%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Mac下安装Redis 先安装homebrew 1“ruby -e &quot;$(curl -fsSkL raw.github.com/mxcl/homebrew/go)” 利用homebrew安装Redis 1brew install redis 启动Redis 1redis-server 客户端连接Redis 1redis-cli //这个命令一定要另开一个终端窗口[Ctr+N] 关闭Redis服务 1shutdown //在客户端终端窗口里面执行 字符串类型-基础命令123456789101112131415161718192021222324252627set [key] [value] //插入数据get [key] //查看对应键名的值keys * //查看所有键名exists [key] //判断该键是否存在del [key] //删除该键type [key] //获得键值的数据类型incr [key] //递增对应键名的键值decr [key] //递减对应键名的键值incrby [key] (int)num //增加指定整数incrbyfloat [key] (float)num //增加指定浮点数append [key] [value] //向尾部追加值，如果追加的字符串开头或结尾包含空格，需要用引号将字符串包起来srelen [key] //获取键值的长度mset [key1] [v1] [key2] [v2] [key3] [v3] //同时设置多个键值mget [key1] [key3] //同时设置多个键值 竞态条件:当同一时间有多个客户端连接到Redis，对同一个键的键值同时执行递增操作，最终的键值却只增加一次 位操作 获取相应二进制位上的的值 1getbit [key] [pos] //位置从0开始 如果需要获取的二进制位的索引超出了键值的二进制位的实际长度则默认位值是0 12“redis&gt; GETBIT foo 100000(integer) 0” 设置相应二进制位上的的值 1setbit [key] [pos] [value] ////位置从0开始 如果要设置的位置超过了键值的二进制位的长度，SETBIT命令会自动将多出的二进制位设置为012“redis&gt; SETBIT nofoo 10000 1(integer) 0” 获得字符串类型键中值是1的二进制位个数 1bitcount [key] “获得字符串类型键中值指定字节区间是1的二进制位个数 1bitcount [key] (start)num (end)num 对多个字符串类型键进行位运算,并将结果存储在指定的键中 1bitop OR [result] [key1] [key2] AND[与运算]&nbsp;&nbsp;&nbsp;&nbsp;OR[或运算]&nbsp;&nbsp;&nbsp;&nbsp;XOR[异或运算] 获得指定键的第一个位值是0或者1的位置 123bitpos [key] 0bitpos [key] 1 指定二进制位的查询范围,获得指定键的第一个位值是0或者1的位置 123bitpos [key] 0 (start)num (end)numbitpos [key] 1 (start)num (end)num 这里的返回结果的偏移量是从头开始算起的，与起始字节无关 如果不设置结束字节且键值的所有二进制位都是1，则当要查询值为0的二进制位偏移量时，返回结果会是键值长度的下一个字位的偏移量。这是因为 Redis 会认为键值长度之后的二进制位都是0。 Redis数据类型 string（字符串类型） hash（散列类型） list（列表类型） set（集合类型） zset（有序集合类型 散列类型-基础命令 赋值与取值 12345678910111213hset key field valuehget key fieldhmset key field value [field value …]hmget key field [field …]hgetall key//示例hset car name BMWhget car namehmset car name BMW color whitehmget car name colorhgetall car 在Redis中每个键都属于一个明确的数据类型，如通过HSET命令建立的键是散列类型，通过SET命令建立的键是字符串类型等等 判断字段是否存在 1hexists key field 当字段不存在时赋值 1hsetnx key field value 增加数字 1hincrby key field increment 散列类型没有 hincr 命令，但是可以通过 hincrby key field 1来实现,如果键不存在，hincrby命令会自动建立该键并默认相应字段在执行命令前的值为“0”。命令的返回值是增值后的字段值。也就是1。 删除字段 1hdel key field [field …] //hdel命令可以删除一个或多个字段，返回值是被删除的字段个数 只获取字段名或字段值 12hkeys keyhvals key 获得字段数量 1hlen key 列表类型-基础命令 向列表两端增加元素 12lpush key value [value …] [value …] [value …]rpush key value [value …] [value …] [value …] 示例 1lpush numbers 1 1 1lpush numbers 2 3 3 2 1 从列表两端弹出元素 12lpop keyrpop key 获取列表中元素的个数 1llen key 获得列表片段 1lrange key (stars)num (stop)num //返回索引从 start到 stop之间的所有元素（包含两端的元素 lrange命令在取得列表片段的同时不会像lpop一样删除该片段，另外lrange返回的值包含最右边的元素 如果start的索引位置比stop的索引位置靠后，则会返回空列表。 如果stop大于实际的索引范围，则会返回到列表最右边的元素 删除列表中指定的值 1lrem key count value //rem命令会删除列表中前count个值为value的元素，返回值是实际删除的元素个数。 根据count值的不同，lrem命令的执行方式会略有差异。 当count &gt; 0时 lrem 命令会从列表左边开始删除前 count 当 count &lt; 0时 lrem 命令会从列表右边开始删除前|count|个值为 value 的元素。 当 count = 0是 lrem命令会删除所有值为 value的元素。 获得/设置指定索引的元素值 12lindex key indexlset key index value 只保留列表指定片段 1ltrim key start 向列表中插入元素 12linsert key before|after pivot value//linsert 命令首先会在列表中从左到右查找值为 pivot 的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面 将元素从一个列表转到另一个列表 1rpoplpush source destination 当source和destination相同时，RPOPLPUSH命令会不断地将队尾的元素移到队首，借助这个特性我们可以实现一个网站监控系统 集合类型-基础命令 增加/删除元素 12sadd key member [member …]srem key member [member …] 获得集合中的所有元素 1smembers key 判断元素是否在集合中 1sismembers key member 集合间运算 123sdiff key [key] [key] [key] //求差集sinter key [key] [key] [key] //求交集sunion key [key] [key] [key] //求并集 获得集合中元素个数 1scard key 进行集合运算并将结果存储 123sdiffstore destination key [key …]sinterstore destination key [key …]sunionstore destination key [key …] 随机获得集合中的元素 1srandmember key [count] 当count为正数时，srandmember会随机从集合里获得count个不重复的元素。如果count的值大于集合中的元素个数，则srandmember会返回集合中的全部元素。 当count为负数时，srandmember会随机从集合里获得|count|个的元素，这些元素有可能相同。 从集合中随机弹出一个元素 1spop key 有序集合类型-基础命令 有序集合类型在某些方面和列表类型有些相似。 二者都是有序的。 二者都可以获得某一范围的元素。但是二者有着很大的区别，这使得它们的应用场景也是不同的。 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访问中间元素的应用。 有序集合类型是使用散列表和跳跃表（Skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度是O(log(N))）。 列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。 有序集合要比列表类型更耗费内存。 增加元素 1zadd key score member [score member …] 获得元素的分数 1zsocre key member 获得排名在某个范围的元素列表 12zrange key start stop [withscores]zrevrange key start stop [withscores] //zrevrange命令是按照元素分数从大到小的顺序给出结果的 如果需要同时获得元素的分数的话可以在 ZRANGE 命令的尾部加上 WITHSCORES 参数 1234567redis&gt; zrange scoreboard 0 -1 withscores1) &quot;Peter&quot;2) &quot;76&quot;3) &quot;Tom&quot;4) &quot;89&quot;5) &quot;David&quot;6) &quot;100&quot; -获得指定分数范围的元素 1“zrangebyscore key min max [withscores] [limmit offset count] 增加某个元素的分数 1zincrby key increment member 示例 12zincrby scoreboard 4 Jerry //加分zincrby scoreboard -4 Jerry //减分 获得集合中元素的数量 1zcard key 获得指定分数范围内的元素个数 1zcount key min max 删除一个或多个元素 1zrem key member [member …] 按照排名范围删除元素 1zremrangebyrank key start stop //从小到大的顺序 按照分数范围删除元素 1zremrangebyscore key min max 示例 1zremrangebyscore testRem (4 5 //不包括4，但是包括5 获得元素的排名 12zrank key member //从小到大zrevrank key member //从大到小 计算有序集合的交集 12zinterstore destination numkeys key [key …] [weight weight [weight …]] [aggregateSUM|MIN|MAX] 当AGGREGATE是SUM时（也就是默认值），destination键中元素的分数是每个参与计算的集合中该元素分数的和。 当AGGREGATE是MIN时，destination键中元素的分数是每个参与计算的集合中该元素分数的最小值。 当AGGREGATE是MAX时，destination键中元素的分数是每个参与计算的集合中该元素分数的最大值。 ZINTERSTORE命令还能够通过WEIGHTS参数设置每个集合的权重，每个集合在参与计算时元素的分数会被乘上该集合的权重。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL操作语言[DML]]]></title>
    <url>%2F2015%2F07%2F03%2FMySQL%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80%5BDML%5D%2F</url>
    <content type="text"><![CDATA[insert操作1insert into table_name (field1, field2,...fieldN) values (value1, value2,...valueN); 如果ID值设置为自增长，列名及其对应的值可以省略不写，但是下面这种写法除外，且值要与列名严格对应1insert into table_name values (value1, value2,...valueN); 对于数据，字符串需要添加“ ”，数字不用。列名则都不需要 update操作12345update table_name set field1=new-value1, field2=new-value2, field3=new-value3 [where Clause] where条件如果不加，影响所有行 delete操作1delete from table_name [where Clause] where条件如果不加，影响所有行 select操作12345678910select column_name,column_name from table_name [where Clause]select column_name,column_name from table_name [where Clause in (value1,value2,value3)]//列举查询select column_name,column_name from table_name [where Clause between value1 and value2]//区间查询select column_name,column_name from table_name [where Clause like &quot;%X%&quot;]//模糊查询 查询模型在查询时可以将列看做变量进行运算1select 列1, 列2, 列1+列2 from table_name [where Clause] [offset M] [limit N] 从表中选出指定的属性值组成一个新表，即为投影；上面的查询语句属于广义投影； where和后面的语句构成一个布尔表达式，解析查询语句时，数据库从头到尾根据where条件遍历整张表的每条记录，如果结果为1，则输出相应的记录结果，如果结果为0，则查看下一条记录，直至查询出结果。例如，查询条件[where 1]将输出整张表，[where 0]将什么也查不到。 奇怪的NUll12select 列1, 列2 from table_name where 列名 is nullselect 列1, 列2 from table_name where 列名 is not null null表示空值，但null=null为假 在设计表时，应尽量不允许使用null group分组统计12345max() //求最大值count() //求行数avg() //求平均数min() //求最小值sum() //求总和 查询格式1select 列1, 列2, sum(列1+列2) from table_name group by 列3 group查询时会先根据where条件对数据进行排序，所以，分组查询是是比较耗费数据库系统资源的，应尽量避免 having筛选结果集1select 列1, 列2, sum(列1+列2) as X from table_name having [X &gt; 100] 在上式中 sum(列1+列2) 就是结果集，然后重命名为 X ，两者可以看做近似相等，但也有不同之处。 where 是对数据表中的原始数据进行筛选，因为X并不是数据表中的原始项，所以会报错。 having 是对已经筛选出来的结果集进行再次筛选，如果将其替换为 where 数据库无法执行。 习题练习 name subject score 张三 数学 90 张三 语文 50 张三 地理 40 李四 语文 55 李四 政治 45 王五 政治 30 查询出2门及2门以上不及格者的平均成绩1select name,sum(score&lt;60) as gk,avg(score) as pj form resule group by name having gk&gt;=2 先查所有人所有科的平均分，再利用having筛选谁挂科量在2门及其以上 order排序1select 列1, 列2 from table_name order by 列3 [asc/desc],列4 [asc/desc] 默认为升序排列【asc】 上式表示先根据列3进行排序，然后结果集再根据列4进行排序，例如，先按照国籍排序，同一国人再按照年龄排序 limit用法1select 列1, 列2 from table_name order by 列3 [asc/desc],列4 [asc/desc] limit [偏移量,取出条数] 偏移量表示跳过前几条数据，如果为0则可以不写 子句查询陷阱1where -&gt; group by -&gt; having -&gt; order by -&gt; limit 5种子句查询有严格的顺序，不允许随意变换 where型子查询1select 列1, 列2 from table_name where 列1 = (select max(列1) from table_name) 内层查询结果作为外层查询条件 from型子查询1select 列1 from (select 列1, 列2 from table_name order by 列3) exists型子查询1select * from 表1 where exists (select * from 表2 where 表1.列1 = 表2.列2) 内连接查询boy表&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;girl表hid|b.name | |hid|g.name—|—-|—|—|—A|屌丝||B|小龙女B|杨过||C|祝英台C|梁山伯||D|腐女 编号一样表示夫妻关系。要求联表查询出具有夫妻关系的人物名称。1234select boy.hid,boy.name,girl.his,girl.name fromboy inner join girlon b.hid = girl.hid 执行结果如下boy.hid|boy.name||girl.hid| girl.name—|—|—|—|—B|杨过||B|小龙女C|梁山伯||C|祝英台 左右连接查询 【继续沿用上面两张表】左连接：以左表为基准，到右表找匹配的数据，找不到匹配的用NULL补齐。查询格式如下1234select boy.hid,boy.name,girl.his,girl.name fromboy left join girlon b.hid = girl.hid boy.hid boy.name girl.hid girl.name A 屌丝 null null B 杨过 B 小龙女 C 梁山伯 C 祝英台 右连接：以右表为基准，到左表找匹配的数据，找不到匹配的用NULL补齐。查询格式如下1234select boy.hid,boy.name,girl.his,girl.name fromboy right join girlon b.hid = girl.hid boy.hid boy.name girl.hid girl.name B 杨过 B 小龙女 C 梁山伯 C 祝英台 null null D 腐女 可以连续进行连表查询，但是在写查询语句时，需要将对连续连接的表起别名，加以区分，避免冲突。 union查询union查询就是把2条或多条的sql查询结果。合并成一个结果集123sql1 --&gt; N 行 sql2 --&gt; M 行 sql1 union sql2 --&gt; N+M 行 使用前提：各语句取出的列数相同，列名称未必要求一致，列名称会使用是一条sql的列名称为准 使用union时，完全相等的行将会被合并【合并时比较耗时的操作】，一般不让union进行合并，使用“union all”可以避免。 union子句中，不用写order by ，因为合并后得到的最后结果可以order by，子句order by失去意义]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax基本知识]]></title>
    <url>%2F2015%2F06%2F30%2FAjax%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Ajax本质：在页面不刷新的情况下，利用XMLHttpRequest发送HTTP请求，可以看做JS的网络化12345678910function vote()&#123; //1、创建XMLHttpRequest对象 var xhr = new XMLHttpRequest(); //2、打开连接，第一个参数表弟传值方式，第二个表示请求哪个页面进行处理，true表示异步，false表示同步 xhr = open(&apos;GET&apos;,&apos;./test.php&apos;,true); //3、发送请求 xhr.send(null); //4、输出返回值 alert(xhr.responseText);&#125; Ajax同步表示发送完请求之后，要等到xhr.responseText拿到返回值才执行第四步，而异步是执行完发送请求后，直接执行第四步，并不需要等待，也不关心xhr.responseText是否拿到返回值 如果使用异步方式，如何知道请求发送完成这个状态呢？这就需要使用onreadystatechange这个属性进行绑定回调函数了 123xhr.onreadystatechange = function ()&#123; alert(&apos;请求成功&apos;);&#125; Ajax不能实现文件上传，因为其调用的XMLHttpRequest对象是属于JS的，但是出于安全考虑JS的对象不能访问本地文件 使用POST方式进行传值1234567891011121314function vote()&#123; //1、创建XMLHttpRequest对象 var xhr = new XMLHttpRequest(); //2、打开连接 xhr = open(&apos;POST&apos;,&apos;./test.php&apos;,true); //3、收集表单数据 var uname = document.getElementById(&apos;uname&apos;).value; var email = document.getElementById(&apos;email&apos;).value; //4、发送请求 xhr.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;) xhr.send(&apos;username=&apos;+uname+&apos;&amp;email=&apos;=email); //5、输出返回值 alert(xhr.responseText);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL定义语言[DDL]]]></title>
    <url>%2F2015%2F06%2F22%2FMySQL%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%5BDDL%5D%2F</url>
    <content type="text"><![CDATA[创建表table123456create table table_name ( 列名 属性, age int, ... name varchar(10)); 整型列 tinyint：1字节，取值范围[-128 ~ 127]，非负取值范围[0 ~ 255] smallint：2字节，取值范围[-32768 ~ 32767]，非负取值范围[0 ~ 65535] mediumint：3字节，取值范围[-8388608 ~ 8388607]，非负取值范围[0 ~ 16777215] int：4字节，取值范围[-21亿 ~ 21亿]，非负取值范围[0 ~ 42亿] bigint：8字节 整型例的可选参数【属性】 各种整型数据类型默认为带符号的取值范围 unsigned：无符号，列的值从0开始，不为负。 [M] zerofill：适合用于学号，编码等固定宽度的数字，可以用0填充至固定宽度，并且默认决定列为unsigned属性。 如果数字位数超过了[M],并不影响，MySQL会字节存取。1alert table table_name add 列名 tinyint(5) zerofill; 添加一个固定宽度为5的列 浮点列与定点列 float[M,D]：浮点型，M表示精度，总位数；D表示标度，小数位数；这两个参数可以省略不写，默认为普通浮点数。 double[M,D]：与上相同，只是默认精度更高。 decimal[M,D]：定点型，float和double有精度损失，而decimal没有，更精确。 字符型列 类型 宽度 可存字符 实存字符[i&lt;=M] 实占空间 利用率 char M M i M &lt;=100% varchar M M i i字符(+1-2)字节 &lt;100% char型如果不够M个字符，内部活用空格补齐，取出时再把右侧空格删掉。[这意味着，如果右侧本身有空格，将会丢失]，但是char速度更快。 M是字符，是几就表示可以存几个汉字。 text：文本型，可存储约6万字。 blob：用来存储二进制文件，如图片，音频等，由于采用的是二进制形式，不用考虑字符集。 enum：枚举型，是定义好值就在某几个枚举范围内。 1234alert table table_name add 列名 enum(&quot;男&quot;,&quot;女&quot;);//只能选址一个值进行插入操作alert table table_name add 列名 set(&quot;男&quot;,&quot;女&quot;); //可以选择一个或多个值进行插入操作 日期时间型列 类型 样式 范围 year 1995 1901~2155 date 1998-12-31 1000/01/01~9999/12/31 time 12:32:45 -838:59:59 ~ 838:59:59 datetime 1998-12-31 12:32:45 - timestamp 1512394064 可不写，系统自动获取 列的默认值因为null查询不便且索引效率不高，所以在实际应用中，应尽量避免列的值为null，如果想避免，声明列not null default “默认值”1alert table table_name add 列名 int not null default 1; 主键与自增主键：次列不重复，能够区分每一行。123456789101112//写法一create table table_name( id int primary key, name char(10));//写法二create table table_name( id int, name char(10), primary key(id)); 自增：一张表，只能有一个自增列，且此列必须加索引[index/key id]12345create table table_name( id int, name char(10), index id(id)); 主键且自增1234create table table_name( id int primary key auto_increment, name char(10),); 列的增删改123456789alert table 表名 add 列名 列类型 列属性； //添加列，默认在表最后alert table 表名 add 列名 列类型 列属性 after 列名； //添加一个新列并放在某列之后alert table 表名 drop 列名； //删除列alert table 表名 change 列名 新列名 新列类型； //修改列名和列类型alert table 表名 modify 列名 新列类型； //只能修改列类型 视图1create view 视图名 as select 列1, 列2, 列3 from table_name; 如果一个查询结果集需要经常被用到，就需要创建视图。 又被称为虚拟表，是sql的查询结果。 作用： 权限控制。 比如说某几个列允许用户查询，其他列不允许，可以通过视图开放其中一列或几列起到权限控制的作用。 简化复杂的查询 如果视图的所有列都来自物理表，那么视图中的数据就可以修改；如果视图中存在某一列或几列是经过物理表中的列进行运算得到的，那么视图中这样的列中的数据就不能被修改。 视图的algorithm [视图放在哪？]12345678//指定使用merge算法create algorithm=merge view 视图名 as select 列1, 列2, 列3 from table_name;////指定使用temptable算法create algorithm=temptable view 视图名 as select 列1, 列2, 列3 from table_name;//由MySQL自己决定使用何种算法create view 视图名 as select 列1, 列2, 列3 from table_name; 对于简单查询形成的view，再对view进行查询时，如where，order等等，可以把建视图语句+查视图语句合并成 –&gt; 查物理的语句。这种视图的算法叫merge [合并] 也有可能创建视图的语句本身就比较复杂，很难在和查询视图的语句进行合并，MySQL可以先执行视图的创建语句，把结果集形成内存中的临时表，然后去查询临时表。这种视图的算法叫temptable [临时表] 常用表管理语句12345678910111213141516171819show tables; //查看所有表,视图也会包含在内。desc 表名; //查看表详细信息drop table 表名; //删除表drop view 视图名; //删除视图show create table 表名/视图名; //查看建表/视图过程show table status \G; //查看所有表详细信息，\G表示竖排显示show table status where name = &apos;表名&apos; \G; //查看指定表详细信息rename table 旧表名 to 新表名; //改表名truncate 表名; //想当于删除后有重建了这个表delete from 表名; //删除表中所有数据，但如果继续插入数据，自增列会在原有基础上继续自增 存储引擎的概念1234create table table_name( id int, name char(10))engine innodb charset utf8; 数据库对同样的数据有着不同的存储方式和管理方式，在MySQL中称之为数据引擎 在MySQL_5.5.5以前默认引擎是Myisam，从MySQL_5.5.5开始，默认引擎改为Innodb Myisam数据组织方式：每一个数据库形成一个文件夹，每张表包含3个文件放在该文件夹下 table_name.frm //表结构文件 table_name.MYD //表数据文件 table_name.MYI //表索引文件 可以直接把文件夹拷走，就是一个完整的数据库 Myisam不支持事务 Innodb数据组织方式：所有数据放在一个文件内 字符集与乱码问题1234create table table_name( id int, name char(10))engine innodb charset utf8; 乱码是因为文字本来的的字符集与展示的字符集不一致导致 校对集：就是排序规则 一套字符集可以有几套校对集 12345character_set_client = &apos;utf8&apos; //设置客户端发送与可接收字符集character_set_connection = &apos;utf8&apos; //设置解释字符集character_set_results = &apos;utf8&apos; //设置数据库返回与可接收字符集set names utf8; //就是将以上三个变量同时设为utf8字符集 解释器可以将不同编码进行翻译 如果客户端和MySQL使用的是不同的字符集，就会出现乱码 连接器使用GBK或者UTF8都可以，但是不可以使用编码范围比较小的字符集，比如ASCII，那样会造成数据丢失 谁能连接数据库谁就是客户端，如PHP和MySQL的控制窗口就是两个不同的客户端 保证HTML文件，数据库，处理脚本（如PHP），查询语句前的声明保持一致，就可以避免乱码 索引的概念12345678910111213key //普通索引，纯粹为了加快查询速度unique key //唯一所以，一是为了加快查询速度，二是为了约束数据 [不能重复]primary key //主键索引，不需要起名，因为一张表就一个fulltext //全文索引，在中文环境下，几乎无效create table table_name( id int, name char(10), key name(name), unique id(id)); 索引是数据的目录，能快速定位行数据的位置，索引提高了查询速度，但是影响了增删改的速度，并非加的越多越好，一般在查询频率比较高的列上加，而且在重复度的列上加效果更好 索引长度：建索引时，可以只索引列的前一部分内容，比如前10个字符 12345create table table_name( id int, name char(10), key name(name(5))); 多列索引：就是把2列或多列的值，看成一个整体然后索引。 12345678910111213create table table_name( xing char(5), ming char(10), key xm(xing,ming));insert into table_name values (&apos;朱&apos;,&apos;元璋&apos;); //插入一条数据select * from table_name where xing = &apos;朱&apos; and ming = &apos;元璋&apos;; //索引生效select * from table_name where xing = &apos;朱&apos;; //索引生效select * from table_name where ming = &apos;元璋&apos;; //索引失效 索引是左前缀发挥作用 冗余索引：就是在某个列上，可能存在多个索引 123456create table table_name( xing char(5), ming char(10), key xm(xing,ming), key ming(ming)); 索引的操作语法123456789show index from 表名; || show create table 表名; //查看索引alter table 表名 drop index 索引名; || drop index 索引名 on 表名; //删除索引alter table 表名 add 索引名(列名); //添加索引alter table 表名 add primary key (列名); //添加主键索引alter table 表名 drop primary key; //删除主键所以 事务的概念1234567891011//事务执行成功start transactionupdate 表名 set money+500 where id=2;update 表名 set money-500 where id=1;commit;//事务执行失败，进行回滚start transactionupdate 表名 set money+500 where id=2;update 表名 set money-500 where id=1;rollback; 比如转账就可以看作一个事务，包含A扣款，B收款两个部分，只有两部分都成功，才能说一个事务完成 事务具有以下四个特点 隔离性：用户看不到事务的中间态 原子性：不论事务中间过程过么复杂，最后结果要么是事务执行之前的状态，要么是事务执行成功的状态 一致性：事务前后的数据保持守恒 持久性：事务一旦执行成功，就不能rollback]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础知识（三、多态）]]></title>
    <url>%2F2015%2F06%2F17%2FPHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%E3%80%81%E5%A4%9A%E6%80%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[多态多态的概念：只抽象的声明父类，具体的工作由子类对象来完成，这样，不同的子类对象完成，有不同的特点1234567891011121314151617181920212223242526272829303132class Light&#123; public function turn_on($arg)&#123; $arg -&gt; show(); &#125;&#125;class RedGlass&#123; public function show()&#123; echo &quot;我是红灯&quot;,&quot;&lt;br /&gt;&quot;; &#125;&#125;class YellowGlass&#123; public function show()&#123; echo &quot;我是黄灯&quot;,&quot;&lt;br /&gt;&quot;; &#125;&#125;class GreenGlass&#123; public function show()&#123; echo &quot;我是绿灯&quot;,&quot;&lt;br /&gt;&quot;; &#125;&#125;$light = new Light();$red = new RedGlass();$yellow = new YellowGlass();$green = new GreenGlass();$light -&gt; turn_on($red);$light -&gt; turn_on($yellow);$light -&gt; turn_on($green); 如果按PHP本身的特点，不检测类型，本身就可以说是多态的，甚至是变态的额，但是PHP5.3以后，引入了对于对象类型的参数检测，注意，只能检测对象所属的类，其实对于PHP来说，限制了其灵活性，达到Java中多态的效果。12345678910111213141516171819202122232425262728293031323334353637//类Java多态class Light&#123; public function turn_on(Glass $arg)&#123; $arg -&gt; show(); &#125;&#125;class Glass&#123;&#125;class RedGlass extends Glass&#123; public function show()&#123; echo &quot;我是红灯&quot;,&quot;&lt;br /&gt;&quot;; &#125;&#125;class YellowGlass extends Glass&#123; public function show()&#123; echo &quot;我是黄灯&quot;,&quot;&lt;br /&gt;&quot;; &#125;&#125;class GreenGlass extends Glass&#123; public function show()&#123; echo &quot;我是绿灯&quot;,&quot;&lt;br /&gt;&quot;; &#125;&#125;$light = new Light();$red = new RedGlass();$yellow = new YellowGlass();$green = new GreenGlass();$light -&gt; turn_on($red);$light -&gt; turn_on($yellow);$light -&gt; turn_on($green); 静态属性与静态方法在属性和方法前加static修饰，这种称为静态属性或方法 从内存角度看，statics属性，存放在类的区域中，普通属性存放在对象中 类声明完毕，静态属性就存在，不需要依赖于对象来访问 因为类在内存中只有一个，因此静态属性也只有一个，被所有对象共享（一个类中可有多个静态属性或方法） 1234class Human&#123; static public $head = 1; &#125;echo Human::$head; 非静态方法，是不能由类名静态调用的，但是，PHP中的面向对象检测并不严格，只要该方法中没有$this，就会转化为静态方法来调用 self与parent详解 self：调用自身类中的属性或方法 parent：调用父类中的属性或方法 12345678910111213141516171819class A&#123; public function a1()&#123; echo &quot;this is function a1()&quot;; &#125;&#125;class B extends A&#123; public function b1()&#123; $this -&gt; a1(); &#125; public function b2()&#123; parent::a1(); &#125;&#125;$b = new B();$b -&gt; b1();$b -&gt; b2(); 从速度角度看，parent速度稍快一点点，因为子类再找a1()方法时，寻找不到，再找父类 但是从面向对象的角度看，继承过来的就是自己的，$this更符合面向对象的思想，因为当继承的层次很深时，用parent：：parent：：parent：：parent这样的方式明显不是很合理 但是当想访问父类的私有属性时，可以通过parent：：parent：：parent：：parent这种方式实现 单例模式在PHP程序开发过程中，为了规范程序设计，使用单例模式对创建对象进行技术规范，避免重复，随意创建对象final在PHP中可以修饰类和方法，不能修饰属性 修饰类时，被修饰的类不能被继承（其不能有子类） 修饰方法时，该方法可以被继承，但是不能被重写 1234567891011121314151617181920212223class Single&#123; public $random = null; static protected $ins = null; final protected function __construct()&#123; $this -&gt; random = mt_rand(1,10); &#125; static public function getInstance()&#123; if(self::$ins instanceof self)&#123; //判断一个对象是不是属于该类 return self::$ins; &#125;else&#123; self::$ins = new self(); return self::$ins; &#125; &#125;&#125;class son extends Single&#123;&#125;$t1 = son::getInstance();$t2 = son::getInstance();print_r($t1);print_r($t2); 单例模式主要思路1.类有一个静态属性存放对象 2.保护或私有构造函数，防止外部实例化 3.内部开放一个公共的静态方法，负责实例化 4.当静态属性已经存放该对象，直接return该对象，否则，先实例化在return 魔术方法 __get()：如果访问的属性没有权限或者不存在，则会自动调用这个魔术方法，并自动把不能访问或者不存在的属性名作为参数，传入方法。 __set()：当为无权操作或者不存在的属性赋值时，方法会被自动调用，且自动传入两个参数，分别是属性和属性值。 __isset()：判断对象不可见属性时（private/protected/不存在），会引发方法执行 __unset()：销毁对象不可见属性时（private/protected/不存在），会引发方法执行，并自动把想销毁的属性名作为参数，传入方法。 __call()：调用一个不能访问或不存在的方法时，会被自动调用，且自动传入两个参数，分别是不能被调用的方法名和以数组形式返回的不能调用的方法的参数 __callstatic()：调用一个不能访问或不存在的静态方法时，会被自动调用，且自动传入两个参数，分别是不能被调用的方法名和以数组形式返回的不能调用的方法的参数 重写与重载 重写/覆盖：子类重写了父类的同名方法 重载：存在多个同名方法，但参数类型或个数不同，传入的参数不同，调用的方法不同，但PHP中不行，因为PHP一个类中不允许有多个同名方法 类常量与魔术常量 普通常量：define(‘name’,’value’);无论是页面内，类内还是函数类都可以访问 类内常量：cons name = ‘lihua’;只能在类内访问 延迟绑定（运行期绑定）12345678910111213141516171819202122class Human&#123; public static function who()&#123; echo &quot;在父类执行&quot;; &#125; public static function say()&#123; //子类没有say方法，找到父类，这里的self指父类 self::who(); &#125; public static function say1()&#123; //子类没有say1方法，找到父类，但是父类调用的是静态方法，调用子类自己的who方法 static::who(); &#125;&#125;class Stu extends Human&#123; public static function who()&#123; echo &quot;在子类执行&quot;; &#125;&#125;$t = new Stu();$t::say();$t::say1(); 抽象类 抽象类：用abstract修饰，不能被实例化，继承抽象类的子类要实现抽象类中的所有抽象方法 抽象方法：用abstract修饰，不能包含方法体（大括号内的内容） 有抽象方法，此类必是抽象类，但在抽象类中，不一定有抽象方法 123456789101112131415161718abstract class Rocket&#123; public abstract function engine(); public abstract function balance();&#125;class Plane extends Rocket&#123; public function engine()&#123; echo &quot;涡扇发动机&quot;; &#125; public function balance()&#123; echo &quot;平衡舵&quot;; &#125;&#125;$plane = new Plane();$plane -&gt; engine(); 接口的概念因为接口的方法本身就是抽象的，；不要有方法体，也不要有abstract1234567891011121314151617181920212223242526272829303132333435363738interface animal&#123; public function eat();&#125;interface monkey&#123; public function run(); public function cry();&#125;interface wisdom&#123; public function think();&#125;interface bird&#123; public function fly();&#125;class Human implements animal,monkey,wisdom&#123; public function eat()&#123; echo &quot;吃&quot;; &#125; public function run()&#123; echo &quot;跑&quot;; &#125; public function cry()&#123; echo &quot;哭&quot;; &#125; public function think()&#123; echo &quot;思考&quot;; &#125;&#125;$lisi = new Human();$lisi -&gt; think(); 接口语言与应用场景 接口本身即是抽象的，内部声明的方法默认也是抽象的，不用加abstract 一个类可以一次性实现多个接口，语法用implements实现，然后再把接口的功能给实现 接口也可以继承，用extends 接口是一堆方法的说明，不能加属性 接口的方法必须是公共的 自动加载如果调用某个不存在的类，在报错之前，我们还有一次介入机会，系统会自动调用autoload()函数，并把类名自动传给autoload()函数1234567function __autoload($c)&#123; require(&apos;./&apos;.$c.&apos;.php&apos;) &#125; $lisi = new Human(); $t -&gt; run();]]></content>
      <categories>
        <category>PHP学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础知识（二、面向对象）]]></title>
    <url>%2F2015%2F06%2F05%2FPHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[PHP面向对象基本概念123456789class People&#123; public $name = &apos;nobody&apos;; public function cry()&#123; echo &apos;呱呱坠地&apos;; &#125;&#125;$man = new Prople();echo $man-&gt;name;echo $man-&gt;cry(); 属性与方法的注意点 对于属性值，可以在声明属性的同时进行赋值，也可以先声明并不进行赋值，如果不复制，属性的默认值为null； PHP的属性值必须是一个“直接的值”，不能是表达式（如：1+2）的值，或者函数的返回值等等 PHP中的函数不能重复定义（即函数名不能重复），但是全局函数名可以和类中的方法名一样 123456789101112131415class Clock&#123; public function time()&#123; echo &apos;现在时间戳是11111111&apos;; &#125; public function time2()&#123; echo &apos;现在时间戳是&apos;,time(); &#125; public function time3()&#123; echo &apos;现在时间戳是&apos;,$this-&gt;time(); &#125;&#125;$c = new Clock();$c-&gt;time(); //现在时间戳是11111111$c-&gt;time2(); //调用系统函数，输出真实的时间戳$c-&gt;time3(); //现在时间戳是11111111 构造函数详解在类中，有一个构造函数，就是用来初始化对象用的，利用构造函数，就有机会操作对象，并改变它的值 工作原理：生成对象时，先按类的声明，把属性凑齐，再用__construct()去影响，再返回该对象123456789101112131415class Human&#123; public function __construct($name,$gender)&#123; $this -&gt; name = $name; $this -&gt; gender = $gender; &#125; public $name = null; public $gender = null; &#125;$a = new Human(&apos;张飞&apos;,&apos;男&apos;);$b = new Human(&apos;李四&apos;,&apos;男&apos;);$c = new Human(&apos;黛玉&apos;,&apos;女&apos;);echo $a -&gt; name,&quot;&lt;br /&gt;&quot;; //张飞echo $b -&gt; name,&quot;&lt;br /&gt;&quot;; //李四echo $c -&gt; name,&quot;&lt;br /&gt;&quot;; //黛玉 构造函数的作用时机：每当new一个对象，就会自动对new出来的新对象发挥作用 new ClassName()传的参数，是给构造函数用的 new ClassName()也可以不传参，但前提是与构造函数里的参数保持一致 一个类中，只允许存在一个构造函数 析构函数构造函数是在对象产生的时候，自动执行 析构函数是在对象销毁的时候，自动执行1234567891011121314151617class Human&#123; public function __construct()&#123; echo &quot;出生喽！&quot;; &#125; public $name = null; public $gender = null; public function __destruct()&#123; echo &quot;还是跪了！&quot;; &#125;&#125;$a = new Human();$b = new Human();$c = new Human();$d = new Human(); //4生4死unset($a); // 出生喽！ 还是跪了！$b = false; // 出生喽！ 还是跪了！$c = null; // 出生喽！ 还是跪了！ 对象的销毁： 显式销毁：unset()，赋值为null，都可以。 PHP是脚本语言，在代码执行到最后一行时，所有申请的内存都要释放，自然，对象的内存也要释放，所以对象也被销毁了 析构函数与回收机制详解在上例中，如果将对象$b进行如下赋值操作$b = true，还是会立即触发析构函数，原理如下: 改变了$b的指向，原来内存中的Object对象就没有人指向它，所以会被回收 1234567891011121314151617181920class Human&#123; public $name = null; public $gender = null; public function __destruct()&#123; echo &quot;死了！&quot;; &#125;&#125;$a = $b = $c = new Human();unset($a);echo &apos;unset a&lt;br /&gt;&apos;;unset($b);echo &apos;unset b&lt;br /&gt;&apos;;unset($c);echo &apos;unset c&lt;br /&gt;&apos;;/*unset aunset b死了unset c*/ 原理如下： this绑定123456789101112class Human&#123; public $name = &apos;lisi&apos;; public function who()&#123; echo $this -&gt; name; &#125; public function test()&#123; echo $name; &#125;&#125;$a = new Human();echo $a -&gt; name,&apos;&lt;br /&gt;&apos;; //lisi$a -&gt; who(); //lisi 当一个对象调用其方法时，该方法执行之前，先完成一个绑定 $this绑到调动此方法的对象【睡调用就绑定谁】 在PHP中，方法想访问成员变量必须要使用this进行绑定，而在Java和C++等其他语言中，可以省略，默认访问成员变量,如test()方法在PHP中不合法，但在Java和C++中却可以 封装的概念123456789101112131415class Human&#123; public $money = 1000;&#125;$lisi = new Human();echo $lis -&gt; money; //1000//对属性进行封装class Human&#123; private $money = 1000; public fuction shoeMoney()&#123; return $this -&gt; money * 0.8; &#125;&#125;$lisi = new Human();echo $lis -&gt; shoeMoney(); 私有的money的属性只能通过相应的方法进行访问，这就是封装在属性上的体现。在方法上的体现也是一个道理。 权限修饰符用来说明：属性/方法的权限特点，写在属性/方法的前面，PHP共有3个权限修饰符 private：私有的，其定义的属性和方法只能在类内部进行访问 protect：保护的 public：公共的，其定义的属性和方法在任意位置都可以访问 1234567891011class Human&#123; public $name = &apos;lisi&apos;; private $money = 1000; public function shoeMoney()&#123; echo $this -&gt; money; &#125;&#125;$a = new Human();echo $a -&gt; name,&apos;&lt;br /&gt;&apos;; //lisiecho $a -&gt; money; //私有属性，在类的外部不可读写$a -&gt; shoeMoney(); //1000 权限控制的BUG1234567891011121314class Human&#123; private $money = 1000; public function getMoney($people)&#123; return $people -&gt; money; &#125; public function setMoney($people)&#123; echo $people -&gt; money -= 500; &#125;&#125;$zhangsan = new Human();$lisi = new Human();echo $lisi -&gt; getMoney($zhangsan);$lisi -&gt; setMoney($zhangsan);print_r($zhangsan); 从生活的角度看，李四读取和改变张三的钱，是不合理的 这是因为在PHP中，并不是以对象为单位俩控制权限，而是以类为单位进行权限控制封装MySQL类 继承的概念12345678910class Human&#123; public $height = 160; public function cry()&#123; echo &apos;呜呜呜呜&apos;; &#125;&#125;class Stu extends Human&#123;&#125;$xiaoming = new Stu();$xiaomming -&gt; cry(); //呜呜呜呜 以一个类为父类，另一个类作为其子类，子类在继承父类的属性和方法的基础上，可以进一步的增添和修改 一个子类只能有一个父类 继承注意事项 私有属性可以理解为不能被继承（其实可以被继承，但无法操作） public和protected都可以继承，并拥有访问和修改的权限 继承时，权限只能越来越宽松或者保持不变，不能越来越严格 构造方法的继承构造方法也是可以继承的，new子类时，如果构造方法继承过来，当然也要自动执行，但继承过来，子类重写了，自然执行子类的构造方法（父类的构造方法就不在调用） public、protected、private权限详解 Public权限最为宽松，在任何地方都可以访问 Protected在自身被定义的类和其子类中可以被访问 Private只能在其被定义的类中访问 在PHP中，如果属性和方法前面什么参数也不写，即public/protected/private都不写，则理解为public]]></content>
      <categories>
        <category>PHP学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础知识（一、静态变量)]]></title>
    <url>%2F2015%2F05%2F24%2FPHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[变量类型在PHP中，一共存在8种变量类型：整型，浮点型，字符串，布尔，数组，对象，null，资源 如果一个变量为null，那么在它被声明后，该变量既不会有值，也不会被标注类型 变量检测isset()函数可以检测变量是否存在，存在返回true，不存在或变量为null返回false 获取变量类型 gettype()函数可以用来获取变量类型 判断是否是我们想要的类型用is_int()，is_float()等等 打印变量 echo：适合打印字符串和数字 print_r：适合打印数组 var_dump：所有类型都可以，既可以打印值同时也会打印变量类型 变量类型转换PHP中变量的类型是可以随时转换的，非常灵活，最常见的是字符串与数字的转换，或是字符串/数字——&gt;布尔值的转换1234//字符串到数字的转换:从左到右截取，直到碰到不合法的数字，截取出来的部分转换成数字再参与运算$a = &quot;12hello&quot;;$a = $a + 3;var_dump($a); //int 15 以下值都被当成布尔型的假，而其他值都被当成布尔型的真 “” (an empty string) 0 (0 as an integer) 0.0 (0 as a float) “0” (0 as a string) NULL FALSE array() (an empty array) $var; (a variable declared, but without a value) 变量赋值 传值赋值：变量各有自己的内存空间，传值后不影响原有变量的值【两个人看两台电视】 引用赋值：两个变量指向公共的内存空间，一个变化，另一个也会变化【两个人看一台电视】 变量销毁unset()函数可以用来销毁变量，但是当两个变量都指向同一个内存空间【即引用赋值】时，销魂其中一个变量，另一个依然存在，并不会被销毁。当所有指向这个内存空间的变量都被销毁时，该公共内存空间才会被回收。 动态变量1234$liubei = &quot;河北&quot;;$laoda = &quot;liubei&quot;;$paihang = &quot;laoda&quot;;var_dump($paihang,$$paihang,$$$paihang); //laoda liubei 河北 算术运算符 除数不能为0 两个数相加的和如果超出了 integer 的范围，将会被解释为 float 取模运算时，结果的正负仅取决于被除数 比较运算符凡运算，必有运算结果：比较运算符的运算结果是布尔类型1234$a = 5;$b = &quot;5&quot;;var_dump($a == $b); //truevar_dump($a === $b); //false 全等于不仅要求值相等，类型也必须一致 三元运算符12345//求两个数中较大的数$a = 10;$b = 15;$c = $a&gt;=$b ? $a : $b;var_dump($c); // 15 逻辑运算符 &amp;&amp;：都为真，值才为真 ||：只要有一个为真，就为真 递增递减运算符12345678910111213141516171819202122232425$b = 5;$a = $b++; //先赋值，再自增var_dump($a,$b); // 5 6$b = 5;$a = ++$b; ////先自增，再赋值var_dump($a,$b); // 6 6字符串运算符//字符串与字符串$a = &quot;Hello&quot;;$b = &quot;world&quot;;$c = $a.$b;var_dump($c); //helloworld//字符串与数字$d = 112;$c = $c.$d;var_dump($c); //helloworld112//下面哪个语句运行速度快$a = &quot;Hello&quot;;$b = &quot;world&quot;;echo $a,$b; //更快echo $a.$b; 赋值运算符1234//一个赋值运算有两个作用：1是把3赋给$a；2是返回运算结果，即3$a = 3;$res = ($a = 3);var_dump($res); // 3 continue和break continue：跳过本次循环 break：直接终止循环 函数概念 一段封装好的代码，可以随时调用 返回值是只得到这个值，并不会直接输出 函数定义格式1234function 函数名()&#123; //执行语句 //return;&#125; 命名规范：命名规则和变量是一致的，但是函数不区分大小写 函数的调用过程与返回值函数调用时，代码执行权进入函数，当函数所有语句执行完毕，函数结束，交回执行权，或者函数碰到return语句时，函数返回，教会执行权。123function test()&#123; return &quot;hello&quot;,&quot;world&quot;; //错误，直返return返回一个值&#125; 函数传参方式123456789101112131415function t($a)&#123; $a += 1;&#125;$a = 3;t($a);echo $a; //3 传参外部$a，相当于将外部$a的值，赋给函数内部$a，而内部$a的值怎么变，和外界无关//引用传值function t2(&amp;$a)&#123; $a += 1;&#125;$b = 5;t($b);echo $b; //6 $a和$b指向同一个地址//不推荐这种传值方式，因为函数内部的语句影响到了函数外部的变量，破坏了函数的封装性 函数中变量的作用域 PHP页面中声明的变量叫“全局变量”，函数内部的变量叫“局部变量” 全局变量无法与局部变量进行交互，只有传参时赋值可以 12345678910111213//如果想局部变量访问全局变量，就需要使用关键字global$a = 22;function t()&#123; global $a; echo $a;&#125;t(); // 22//超全局变量，在页面的任何部分，包括函数，方法等，都可以直接访问function t2()&#123; print_r($_GET);&#125;t2(); 动态调用函数可用用变量的值当做函数名，并调用函数12345678910function wel()&#123; echo &quot;wlecome&quot;;&#125;function beat()&#123; echo &quot;beat&quot;;&#125;$heart = &quot;wel&quot;;$heart(); // welcome 字符串定义方式1234567891011121314//定义短字符串$str1 = &apos;hello&apos;;$str2 = &quot;world&quot;;//定义大段字符串//heredoc$str3 = &gt;&gt;&gt;mark 大段string本身;mark;//nowdoc$str3 = &gt;&gt;&gt;&apos;mark&apos; 大段string本身;mark; 单双引号的对比 单引号只转义两个符号：’ 和 \ 双引号可以解析变量 单引号不需要解析字符串内有没有变量，需要转义的内容也少，速度比双引号要快，优先使用单引号 heredoc与nowdoc的区别就是单引号与双引号的区别 数组的声明方式数组是一种复合数据，可以装下多个值，每个值用不同的键来区分1234567$arr = array(&apos;001&apos;=&gt;&apos;春&apos;,&apos;002&apos;=&gt;&apos;夏&apos;,&apos;003&apos;=&gt;&apos;秋&apos;,&apos;004&apos;=&gt;&apos;冬&apos;);//索引数组：键不必有特殊意义，纯数字，这种叫“索引数组”$arr = array(1=&gt;&apos;东&apos;,2=&gt;&apos;西&apos;,3=&gt;&apos;南&apos;,4=&gt;&apos;北&apos;,);//关联数组：字符串做键，一般能体现该单元的内容$stu = array(&apos;name&apos;=&gt;&apos;小明&apos;,&apos;age&apos;=&gt;&apos;20&apos;);//多维数组：数组里面有数组$arr = array(0=&gt;&apos;a&apos;,1=&gt;array(&apos;stu&apos;=&gt;&apos;li&apos;,&apos;bag&apos;=&gt;array(&apos;语文&apos;,&apos;数学&apos;))); 数组键的规则 如果不声明键，会从0，1，2，3……递增来生成键 如果已经存在1或几个数字键，则从最大的数字键，递增生成数字键 如果键声明重复了，后面的值覆盖前面的值 键可以是整数（浮点数会转化为整数）也可以是字符串，如果字符串的内容恰好是整数，也理解成整数 操作数组单元12345678910$arr = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);//增加一个单元$arr[] = &apos;d&apos;;$arr[99] = &apos;e&apos;;//读取单元值echo $arr[3];//改一个单元的值$arr[0] = &apos;A&apos;;//删除某个单元unset($arr[1]); 遍历数组123456789101112131415//对于0，1，2……递增的索引数组，使用for循环$arr = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;);for($key=0; $key&lt;count($arr); $key++)&#123; echo $arr[$key],&quot;&lt;br /&gt;&quot;;&#125;//对于关联数组，使用foreach遍历$arr = array(&apos;name&apos;=&gt;&apos;lisi&apos;,&apos;age&apos;=&gt;&apos;20&apos;,&apos;height&apos;=&gt;&apos;180cm&apos;);foreach($arr as $key =&gt; $value)&#123; echo $key,&apos;:&apos;,$value,&apos;&lt;br /&gt;&apos;;&#125;foreach($arr as $v)&#123; echo $v,&apos;&lt;br /&gt;&apos;;&#125; 数组游标操作12345678910111213141516171819//取当前游标指向的数组单元的值$arr = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);echo current($arr); //a//把数组的游标往后移next($arr);echo current($arr); //b//把数组的游标移到最后end($arr);echo current($arr); //c//把数组的游标往前移prev($arr);echo current($arr); //b//重置游标reset($arr);echo current($arr); //a 超级全局变量 $_GET：地址栏上获取的值 $_POST：POST表单发送的数据 $_REQUEST：既有GET也有POST的内容，如果含有相同的数据，POST会覆盖GET，而这可以再php.ini配置文件中进行设置更改 $_ENV：操作系统的相关环境信息，容易暴露服务器信息，一般不允许打印，可通过修改php.ini实现 $_SERVER：端口，IP地址等环境信息 $_DLOBALS：是对全局变量花名册的一个别名，通过该变量，可以任意访问全局变量，简单说，就是将所有全局变量变成其数组里的一个单元 常量系统12define(&apos;PI&apos;,3.14);echo PI; 命名规范：与变量一样，不过习惯上全部大写 声明后，值不能修改，也不能重新声明，也不能销毁这个变量 常量名前不加$ 常量一旦定义后，在页面的任何位置都可以访问 12345678//检测常量是否存在defined(&apos;PI&apos;);//动态常量名define(&apos;PI&apos;,3.14);$pai = &apos;PI&apos;;echo constant(&apos;PI&apos;); //3.14echo constant($pai); //3.14 文件包含文件包含的作用在于代码的重用，我们可以把常用的代码写到一个文件里，当需要这些代码工作时，直接引入这些文件就可以了 include(); include_once(); require(); require_once(); _once的作用：只引用一次，如果之前已经引用过，就不再引用，但是不叫_once执行速度快一些 include和require的区别：如果引入的文件不存在，include尽量往下执行，报warning，require则直接报fatal error，脚本立即停止执行 浮点数不精确123456if((0.3 - 0.2) == 0.1)&#123; echo &quot;相等&quot;;&#125;else&#123; echo &quot;不相等&quot;;&#125;//输出 不相等 某些小数在十进制下，是有限的，转成二进制要无限循环，因此，损失一些精度，导致浮点数计算和数学上结果不一致 逻辑运算的短路特性12345678910111213$a = 3;$b = 5;if($a=5 || $b=7)&#123; $a++; $b++;&#125;echo $a; //1echo $b; //6/* 或运算的优先级比赋值运算的优先级高，经过或运算，得到布尔值true，再赋值给$a，但是布尔值的自增或自减 并不影响自身，所以true值以数字1的形式输出，$b输出结果为6*/ 递归12345678//0-100求和function sum($n)&#123; if($n == 1)&#123; return 1; &#125; return $n + sum($n-1);&#125;echo sum(100); //5050 静态变量static变量有一个特点，在第一次函数调用声明之后存在，且不随函数结束而结束，当函数再次调用时，可以直接利用上次结果]]></content>
      <categories>
        <category>PHP学习笔记</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript高级知识（二）]]></title>
    <url>%2F2015%2F04%2F11%2FJavaScript%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JS面向对象的特点 在JS中，有对象，没有类（但有构造函数），因此，有人说JS是“基于对象”而非面向对象，其实JS的面向对象非常灵活，比起静态语言，能达到意想不到的效果。 JS的对象不依赖类而存在，可以直接生成。 1var chicken = &#123;leg:2,sing:function()&#123;alert(&quot;在下是鸟！&quot;);&#125;&#125;; //json格式 JS对象的属性可以任意添加和删除（方法和属性不必严格区分） 123var chicken.arm = 2; //添加属性delete chicken.sing; //删除方法对象的三大特点：封装，继承，多态 私有属性与封装1234567891011121314151617181920212223242526272829//封装function Dog()&#123; this.leg = 4; this.bark = function()&#123; alert(&quot;汪汪&quot;); &#125;&#125;var huzi = new Dog();huzi.bark(); //输出 汪汪alert(huzi.leg); //输出 4/*此处，我们并没有完成面向对象的“封装”，所谓封装：就是要封闭一部分，外界无法访问，开放一部分，通过开放部分简介访问私有部分。*///通过闭包完成私有属性的封装function Dog(name,feature)&#123; var private = feature; //外界无法直接访问，只能通过对象属性调用 this.leg = 4; this.eat = function()&#123; return feature; &#125; this.favorite_eat = function()&#123; feature = &quot;骨头&quot;; &#125;&#125;var dog = new Dog(&quot;huzi&quot;,&quot;吃屎&quot;);alert(dog.name + &quot;喜欢&quot; + dog.eat());alert(dog.name + &quot;喜欢&quot; + dog.favorite_eat()); 详解原型链继承JS没有类的概念，因此，JS的继承，不是通过类的继承来实现的，而是通过“原型”的概念来完成的。 123456789101112131415161718//创建cat的构造函数function Cat()&#123; this.climb = function()&#123; alert(&quot;我会爬树&quot;); &#125;&#125;//创建tiger的构造函数function Tiger()&#123; this.bark = function()&#123; alert(&quot;我是百兽之王&quot;); &#125;&#125;//下面让虎继承猫的属性：爬树Tiger.prototype = new Cat();var hnhu = new Tiger();hnhu.climb();hnhu.valueOf(); 老虎是如何爬树和valueOf的呢? 老虎先在自身对象上寻找，没有爬树方法，valueOf()方法，去找原型，原型cat对象上由此方法，得以调用climb()方法，但valueOf()仍没有找到，因此，继续沿着原型查找，找到cat空对象，仍没有valueOf()放法，再找，找到Objecte对象，有valueOf()方法，调用成功。 对象–&gt;原型–&gt;原型的原型–&gt;Object对象–&gt;Null，这样的一条链称为原型链 对象的属性和方法，就是沿着原型链查找和调用的，也就是JS中的原型继承 12345678910//给所有对象添加一个方法Object.prototype.sing = function()&#123; alert(&quot;我会唱歌&quot;);&#125;function Pig()&#123; this.eat = &quot;10KG&quot;;&#125;var zhu = new Pig();zhu.sing(); 原型冒充及复制继承 JS的语法非常灵活，不仅可以用原型继承，还有其他办法，如：原型冒充或复制继承12345678910111213141516171819//原型冒充function Cat(leg,tail)&#123; this.leg = leg; this.tail = tail; this.climb = function()&#123; alert(&quot;我会爬树&quot;); &#125;&#125;function Tiger(leg,tail,color)&#123; //把要继承的类的语句，拿来执行一遍 this.parent = Cat; //把父类构造函数引入到一个parent属性上 this.parent.apply(this,arguments); //获取Cat参数 this.color = color; delete this.parent;&#125;var tiger = new Tiger();tiger.climb(); 用Tiger造对象时，用Tiger语句影响一个空对象{ }，在此过程中，Tiger影响空对象前，先由Cat函数实施影响，因此，最终得到的对象，是由Cat和Tiger两者共同作用过得对象。 123456789101112131415161718192021//复制继承function Cat(leg,tail)&#123; this.leg = leg; this.tail = tail; this.climb = function()&#123; alert(&quot;我会爬树&quot;); &#125;&#125;function Tiger(leg,tail,color)&#123; this.color = color; this.extend = function(parent)&#123; for(var key in parent)&#123; this[key] = parent[key]; &#125; &#125;&#125;var tiger = new Tiger(&quot;yellow&quot;);tiger.extend(new Cat(4,1));tiger.climb(); 动态语言谈不上多态 JS谈不上多态，因为即JS就没有限制参数类型1234567891011121314151617181920212223242526function Dog()&#123; this.leg = 4; this.bark = null;&#125;function Hashiqi()&#123; this.bark = function()&#123; alert(&quot;wuwu&quot;); &#125;&#125;function Jingba()&#123; this.bark = function()&#123; alert(&quot;wuwu&quot;); &#125;&#125;Hashiqi.prototype = Jingba.prototype = new Dog();var h = new Hashiqi();var j = new Jingba();function test(dog)&#123; dog.bark();&#125;test(h);test(j); 传入不同的狗，叫声也不同 JS面向对象之静态方法 构造函数通过new来制造对象 函数本身也是对象 12345678910111213function Machine()&#123; this.on = function ()&#123; alert(&quot;我可以制作豆浆！&quot;); &#125;&#125;Machine.heat = function()&#123; alert(&quot;加热！&quot;);&#125;var m = new Machine(); //m没有heat方法，就像豆浆机的加热功能不会跑到豆浆里m.on();Machine.heat(); heat方法属于函数本身的，和返回的对象没有关系 on要调用，必须要new Machine();得到对象，且由返回对象才能调用 heat方法要调用，不需要new对象，直接用Machie来调用 绑定事件的2种常用方式 事件对象：事件发生的一瞬间，关于事件的各种信息，如时间，如发生时鼠标在屏幕上的坐标，事件类型等等，这些信息被打包成一个对象，便于我们获取 1234567891011121314151617/*第一种事件绑定方式：把事件写在标签属性里，如：&lt;a href=&quot;#&quot; onclick=&quot;t()&quot;&gt;百度&lt;/a&gt;这是DOM 0级标准（非常古老）好处：大家都会，几乎所有的浏览器都支持坏处：代码夹杂在HMTL中，不简洁，其次，这种事件写法，效率不高，再者不符合“行为，结构，样式”相分离*///第二种事件绑定方式：用事件的属性来绑定函数document.getElementById(&quot;test&quot;).onclick = function()&#123; alert(&quot;有人点我&quot;);&#125; /*好处1：完成了行为的分离好处2：便于操作当事对象，因为function是作为对象的on***属性出现的，因此，函数里操作该对象，直接用this就能引用当事对象好处3：方便读取事件对象*/ addEventListener高级事件绑定第三种事件绑定方式：W3c中的标准——addEventListener 绑定在哪个事件上？click，load，change，blur，focus等等 绑定什么函数？——自定义事件函数 什么方式监听执行事件函数？——捕捉，冒泡。 1234var test = document.getElementById(&apos;test&apos;);test.addEventListener(&apos;click&apos;,function()&#123;this.style.background = &quot;gray&quot;;&#125;,false);test.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;自学！&quot;);&#125;,false);test.addEventListener(&apos;click&apos;,function()&#123;alert(&quot;IT&quot;);&#125;,false); 细节： 事件名一律不带on 绑定事件函数的“this”，指绑定该事件的对象 执行顺序是按绑定顺序来执行的。 捕捉模型与冒泡模型12345678910function $(id)&#123; return document.getElementById(id);&#125;$(&quot;china&quot;).addEventListener(&apos;click&apos;,function()&#123;alert(&quot;进入chian&quot;);&#125;,true);$(&quot;bj&quot;).addEventListener(&apos;click&apos;,function()&#123;alert(&quot;进入bj&quot;);&#125;,true);$(&quot;hd&quot;).addEventListener(&apos;click&apos;,function()&#123;alert(&quot;进入hd&quot;);&#125;,true);$(&quot;china&quot;).addEventListener(&apos;click&apos;,function(ev)&#123;alert(&quot;离开chian&quot;);&#125;,false);$(&quot;bj&quot;).addEventListener(&apos;click&apos;,function()&#123;alert(&quot;离开bj&quot;);&#125;,false);$(&quot;hd&quot;).addEventListener(&apos;click&apos;,function()&#123;alert(&quot;离开hd&quot;);&#125;,false); 总结： 第三个参数true/false代表捕捉/冒泡模型，如果不填，默认为false（不建议省略） 系统会为事件函数自动传入事件对象，作为第一个参数传入：ev 事件停止传播与效果阻止 事件（捕捉/冒泡）的过程中，如果想停止事件的传播，比如：被bj捕捉后，hd就不会再去捕捉了，事件到此停止，或hd冒泡后，事件结束，bj就不能冒泡。就需要使用事件对象的stopPropagation();函数 123456function $(id)&#123; return document.getElementById(id);&#125;$(&quot;china&quot;).addEventListener(&apos;click&apos;,function()&#123;alert(&quot;进入chian&quot;);&#125;,true);$(&quot;bj&quot;).addEventListener(&apos;click&apos;,function(ev)&#123;alert(&quot;进入bj&quot;;ev.stopPropagation(););&#125;,true);$(&quot;hd&quot;).addEventListener(&apos;click&apos;,function()&#123;alert(&quot;进入hd&quot;);&#125;,true); 以表单为例，我想点击“onsubmit”时，检查是否填写完全，如果不完全，不让它提交，即取消事件本应有的效果，就需要使用事件对象的preventDefault();函数 12345$(&quot;form&quot;).addEventListener(&apos;submit&apos;,function(ev)&#123; if($(&quot;age&quot;).value = &apos;&apos;)&#123; ev.preventDefault(); &#125;&#125;,false); 解除绑定12345678910111213141516171819202122232425262728293031&lt;p&gt;哈哈&lt;/p&gt;&lt;input type=&quot;button&quot; value=&quot;让你哭&quot; onclick=&quot;addcry()&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;让你笑&quot; onclick=&quot;addla()&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;你别哭&quot; onclick=&quot;remcry()&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;你别哭&quot; onclick=&quot;remcry()&quot;&gt;&lt;script&gt; function cry()&#123; alert(&quot;我想哭！&quot;); &#125; function la()&#123; alert(&quot;我想笑！&quot;); &#125; function addcry()&#123; document.getElementsByTagName(&apos;p&apos;)[0].addEventListener(&apos;click&apos;,cry,false); &#125; function addla()&#123; document.getElementsByTagName(&apos;p&apos;)[0].addEventListener(&apos;click&apos;,la,false); &#125; function remcry()&#123; document.getElementsByTagName(&apos;p&apos;)[0].removeEventListener(&apos;click&apos;,cry,false); &#125; function remla()&#123; document.getElementsByTagName(&apos;p&apos;)[0].removeEventListener(&apos;click&apos;,la,false); &#125;&lt;/script&gt; IE事件模型与标准事件模型详细对比 IE9及以上版本，已经支持W3c标准，在IE9以下版本中，是IE独有的事件模型，与W3c标准模型主要有以下几点不同： 绑定事件的函数不一样，IE用attachEvent();，移除事件函数用detachEvent(); 事件必须要加on 绑定的事件不是严格的顺序执行，是随机执行 W3c中，this指向对象本身，而IE模型中，this指向window 1234window.onload = function()&#123; document.getElementById(&apos;test1&apos;).attachEvent(&apos;onclick&apos;,function()&#123;alert(&quot;捕捉&quot;);&#125;,true); document.getElementById(&apos;test1&apos;).attachEvent(&apos;onclick&apos;,function()&#123;alert(&quot;冒泡&quot;);&#125;,false);&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript高级知识（一）]]></title>
    <url>%2F2015%2F04%2F06%2FJavaScript%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[作用域123456789101112&lt;script&gt; var a = 2; function t1()&#123; var b = 3; function t2()&#123; var c = 4; alert(a+b+c); &#125; t2(); &#125; t1();&lt;/script&gt; 在JS中，函数嵌套是非常普遍的，在函数嵌套中，对变量进行如下的寻找方式：首先在函数内寻找，寻找不到，则往函数外层寻找，……，直到全局（window）区域 声明变量var var是在函数运行的上下文中，声明一个变量，如果不加var，则是一个赋值操作，但不要狭隘的理解为–&gt;声明了一个全局变量【见下例】 12345678910111213&lt;script&gt; function t1()&#123; var a; function t2()&#123; a = 2; b = 4; &#125; t2(); &#125; t1(); console.log(a); //输出undefined console.log(b); //输出2&lt;/script&gt; 以window.xxx引用全局变量，寻找不到，作为某个属性不存在，返回undefined 【window.a】 直接以xxx引用某个变量，寻找不到，则是报xxx is not defined错误的 【a】 123456789&lt;script&gt; &lt;script&gt; var str1 = &quot;global&quot;; var str1 = &quot;global&quot;; function t1()&#123; function t1()&#123; console.log(str1); //global console.log(str1); //global console.log(str2); // str is not definded console.log(str2); //undefinded str2 = &quot;local&quot;; var str2 = &quot;local&quot;; &#125; &#125; t1(); t1();&lt;/script&gt; &lt;/script&gt; JS代码自上而下执行，但是，JS代码在整体运行时分为【词法分析期】和【运行期】两部分 自上而下执行之前，先有一个【词法分析】过程，以上面的结果为例： 123456789第一步：分析t1() t1()&#123; var str2; //分析出t1内有str2局部变量，注意此时函数未执行，因此str2的值是undefined &#125; 第一步：执行t1() console.log(str1); //global console.log(str2); //undefinded str2 = &quot;local&quot;; //此时str2的值为local 词法分析语法分析，分析3样东西： 第一步：先分析参数 第二步：在分析变量声明 第三步：分析函数声明 一个函数能使用的局部变量，就从上面的3步分析而来 具体步骤： 第一步：函数运行前的一瞬间，生成Active Object（活动对象），下称AO 第二步：把函数声明的参数，形成AO的属性，值全是undefined，如果有实参，则接收，并形成AO相应的属性的值 第三步：分析变量声明！如var age，如果AO上还没有age属性，则添加AO属性，值是undefined；如果AO上已经有age属性，则不做任何影响 第四步：分析函数声明，如 function foo(){ }，则把函数赋给AO.foo属性，如果此前foo属性已经存在，则被无情的覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;script&gt; function t3(great)&#123; var great = &quot;hello&quot;; alert(great); function great()&#123; &#125; alert(great); &#125; t3(null); //输出 hello hello&lt;/script&gt;/* 分析过程： 1.形成AO = &#123;&#125; 2.分析形参，AO = &#123;great:undefined&#125;，接收实参，AO = &#123;b:null&#125; 3.分析great变量声明，发现AO已有age属性，不做任何影响 4.分析great函数声明，AO.great = function great()&#123;&#125;,被覆盖成函数 执行过程： great = &quot;hello&quot;; alert(great); alert(great);*/&lt;script&gt; function a(b)&#123; alert(b); function b()&#123; alert(b); &#125; b(); &#125; a(1); &lt;/script&gt;/* 分析过程： 1.形成AO = &#123;&#125; 2.分析形参，AO = &#123;b:undefined&#125;,接收实参，AO = &#123;b:1&#125; 3.分析var变量声明，此函数没有var 4.分析函数声明，AO = &#123;b:function b()&#123;alert(b);&#125;&#125;,被覆盖成函数 执行过程： alert(b); //function b(); //由作用域寻找到a函数中的b,即function*/&lt;script&gt; function a(b)&#123; alert(b); b = function ()&#123; alert(b); &#125; b(); &#125; a(1); &lt;/script&gt;/* 分析过程： 1.形成AO = &#123;&#125; 2.分析形参，AO = &#123;b:undefined&#125;,接收实参，AO = &#123;b:1&#125; 3.分析var变量声明，此函数没有var 4.分析函数声明，没有！b = function()&#123;&#125;,是一个赋值，在执行期才有用 执行过程： alert(b); // 1 b = function ()&#123; alert(b); &#125; b(); //由作用域寻找到a函数中的b,即function*/ 函数声明与函数表达式 函数可以赋值给变量，也可以作为参数来传递 JS被称为披着C外衣的lisp语言，lisp是一种强大的函数式语言 12345678910111213141516171819202122function t1()&#123;&#125;t2 = function()&#123;&#125;/*这两种方式效果是不同的：t1是函数声明，虽然全局内也得到一个t1变量，值是function而t2只是一个赋值过程，值就是右侧表达式的返回结果，即函数因此t1,t2两种方式在词法分析时，有着本质去区别：前者在词法分析阶段就发挥作用，而后者，在运行阶段才发挥作用*/(function(window,undefined)&#123;&#125;) //内层表达式，返回值是函数，包在小括号里，当成表达式来执行(function(window,undefined)&#123;&#125;)(window) //立即调用/*内层函数没有起名字，称为匿名函数，这种手法，匿名函数，立即执行，不污染全局，称为立即执行匿名函数表达式，在第二个括号里面传入window，是为了我提升内部查找变量的速度，不传undefined,是为了安全，因为在低版本IE和火狐中，undefined可以被重新赋值，如undefined = 3，声明undefined局部变量（名字是undefined而已），同时，又不传参，值自然是undefined，防止了外界对undefined的污染*/ 作用域链 argumengs详解 是一个长得很像数组的对象 内容是函数运行时的实参列表 12345678910111213141516171819202122//arguments收集“所有”的实参，即使没有与之相对应的形参(function(d,e,f)&#123; //在此函数内，无法用d,e,f形参来取得“haha”,因为没有与之相应的形参，但我们可以用arguments来获取任意多个实参 console.log(arguments[3]); arguments[3] = &quot;china&quot;; console.log(arguments[d]); //输出 china，形参与对应的arguments单元，其实是相互映射的，互相影响&#125;)(&quot;hello&quot;,&quot;world&quot;,&quot;!&quot;,&quot;haha&quot;)//arguments可以获取函数运行时，收到的实参个数（在多态里可以用到）(function(d,e,f)&#123; console.log(arguments.length); //输出 3&#125;)(&quot;hello&quot;,&quot;world&quot;,&quot;!&quot;,&quot;haha&quot;)//arguments.callee属性代表“当前运行的函数”(function()&#123; //不用函数名，匿名函数，立即执行，完成递归 if(n &lt;= 1)&#123; return 1; &#125;else&#123; return n + arguments.callee(n-1); &#125;&#125;)(100); 函数运行期内，有三个关键的对象： AO ——&gt; 本函数AO上没有某属性，则继续去外层函数的AO上找，直到全局对象，叫做 作用域链 arguments ——&gt; 每个函数都有自己的callee，但不会向外层函数接着找arguments的相关属性，即不形成链 this ——&gt; 也不形成链 this详解 在JS中函数有4种调用方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869alert(window.x); //输出 undefinedfunction t()&#123; this.x = 333;&#125;t();alert(window.x); // 输出 333/*作为普通函数来调用时，this的指向window，准确的说，this为null，但被解释成window，但在ECMASCRIPT标准中，如果this为null则解释成undefined*///作为对象的方法来调用，this指向方法的调用者，即该对象var obj = &#123;xx:999,yy:888,t:function()&#123;alert(this.xx);&#125;&#125;;obj.t(); //输出 99var dog = &#123;xx:&quot;wangwang&quot;&#125;;dog.t = obj.t;dog.t() //输出 wangwang/*作为方法调用时，this指向其调用那一刻的调用者，即母体对象，不管被调用函数，声明时属于方法还是函数，*///函数作为构造函数调用时//JS中没有类的概念，创建对象是用构造函数来完成，或直接用json格式来写对象function Dog (name,age)&#123; this.name = name; this.age = age; this.bark = function()&#123; alert(&apos;I am &apos; + this.name + &apos;!&apos;); &#125;;&#125;var dog = new Dog(&apos;huzi&apos;,2);dog.bark();/*new Dog发生了以下几个步骤：1.系统创建空对象&#123;&#125;，（空对象construcor属性指向Dog函数，先别管）2.把函数的this ——&gt; 指向该空对象3.执行该函数4.返回该对象*/function Pig()&#123; this.age = 99; return &apos;abc&apos;;&#125;var pig = new Pig(); //返回pig对象，因为函数作为构造函数运行时，return的值是忽略的，还是返回对象//函数通过call，apply调用//语法格式：函数.call(对象，参数1，参数2，……，参数N);function t (num)&#123; alert(&apos;我的真实年龄是&apos;+ this.age); //输出 我的真实年龄是28 alert(&apos;但我告诉别人是&apos;+ (this.age+num)); //输出 但我告诉别人是18 &#125;var human = &#123;name:&apos;lisi&apos;,age:28&#125;;human.t = t;human.t(-10); //this指向了human，但human多了一个方法//接下来我们不把t赋为human的属性，也能把this指向humanvar wangwu = &#123;name:&apos;wangwu&apos;,age:30&#125;;t.call(&apos;wangwu&apos;,5); //输出 我的真实年龄是30 但我告诉别人是35/*解释fn.call(对象，参数1，参数2，……，参数N);运行如下：1.fn函数中的this ——&gt; 指向对象obj2.运行fn(对象，参数1，参数2，……，参数N);*/ 闭包 在大部分语言中，t1被调用执行，则申请内存并把其局部变量push入栈。t1函数执行完毕，内部的局部变量，随着函数的退出而销毁，因此age = 20的局部变量已经消息。 但是在JS中，age = 20这个变量，却被t2捕捉，即使t1执行完毕，通过t2，依然能访问该变量 像这种情况：返回的函数，并非孤立的函数，甚至把其周围的变量环境，形成了一封闭的“环境包”，共同返回，所以叫闭包。 一句话概括：函数的作用域取决于声明时，而不取决于调用时！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识（二）]]></title>
    <url>%2F2015%2F03%2F30%2FJavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[联动菜单123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;select name=&quot;prov&quot; id=&quot;prov&quot; onchange=&quot;change();&quot;&gt; &lt;option value=&quot;-1&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;河南&lt;/option&gt; &lt;/select&gt; &lt;select name=&quot;city&quot; id=&quot;city&quot;&gt; &lt;/select&gt; &lt;script&gt; var area = [ [&apos;东城区&apos;,&apos;西城区&apos;,&apos;海淀区&apos;], [&apos;郑州&apos;,&apos;洛阳&apos;,&apos;开封&apos;] ]; function change()&#123; var sel = document.getElementById(&quot;prov&quot;); var opt = &apos;&apos;; var len = area[sel.value].length; if(sel.value == -1)&#123; document.getElementById(&apos;city&apos;).innerHTML = opt; return; &#125; for(var i=0; i&lt;len; i++)&#123; opt = opt + &apos;&lt;option value=&quot;+ &apos;+ i +&apos;&quot;&gt;&apos; + area[sel.value][i] + &apos;&lt;/option&gt;&apos;; &#125; document.getElementById(&apos;city&apos;).innerHTML = opt; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 定时器window.setTimeout(‘语句’,毫秒);指定毫秒后执行一次语句[仅执行一次] window.setInterval(‘语句’,毫秒);指定毫秒后执行语句[循环执行] 定时器不属于JS的知识，它是window对象提供的功能123456789&lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt; &lt;script&gt; function boom()&#123; document.getElementsByTagName(&apos;img&apos;)[0].src = &apos;2.jpg&apos;; &#125; setTimeout(&apos;boom()&apos;,3000);&lt;/script&gt; 清除定时器 clearTimeout(); clearInterval(); 1234&lt;script&gt; var clock = setTimeout(&apos;boom()&apos;,3000); clearTimeout(clock);&lt;/script&gt; 常用事件 onclick //元素点击事 onfocus //元素获得焦点时 onblur //元素失去焦点时 onmouseover //鼠标经过时 onsubmit //表单提交时，写在form标签内 12&lt;form action=&quot;#&quot; onsubmit=&quot;return t1();&quot;&gt;&lt;/form&gt;onload //加载完毕时 事件-行为-结构相分离 123456 &lt;script&gt; function boom()&#123; document.getElementsByTagName(&apos;img&apos;)[0].src = &apos;2.jpg&apos;; &#125; document.getElementsByTagName(&apos;img&apos;)[0].onclick = boom;&lt;/script&gt; 事件委托[五子棋]123456&lt;script type=&quot;text/javascript&quot;&gt; var i = 0; document.getElementsByTagName(&apos;table&apos;)[0].onclick = function(ev)&#123; ev.target.style.background = i%2 ? &quot;black&quot; : &quot;white&quot;; i++;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识（一）]]></title>
    <url>%2F2015%2F03%2F24%2FJavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DOM对象文档对象模型简称DOM，是W3C组织推荐的处理可扩展置标语言的标准编程接口。 DOM实际上是以面向对象方式描述的文档模型。DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。 通过DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性。可以对其中的内容进行修改和删除，同时也可以创建新的元素。 DOM 独立于平台和编程语言。它可被任何编程语言诸如 Java、JavaScript 使用。 DOM对象，即是我们用传统的方法(javascript)获得的对象。 DOM准确说是对文档对象的一种规范标准(文档对象模型),标准只定义了属性和方法行为 JS的引入 直接在HTML中写 123&lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;Hello, World!&quot;;&lt;/script&gt; 外部导入 1&lt;script src=&quot;text_name.js&quot;&gt;&lt;/script&gt; 注意事项：JS最好在HTML文件末尾引入 一是为了提升页面加载速度 二是为了生成完整的DOM对象，避免JS执行失效 变量声明 可以用_、数字、字母、$、组成，且数字不能开头 用 var 来声明变量，如果不用var声明，也不会报错，但是会污染全局变量 JS基本变量类型 数值型 字符串类型 布尔类型 undefined型：原生数据类型变量[以上3种，其本身也是]没有值，返回的是undefined null型：对象类型变量[DOM对象，数组等]没有值，返回的是null JS组合数据类型 对象类型1234567//声明var object = &#123;name:&apos;zhangsan&apos;, age:20&#125;;//调用console.log(object.name);//也可以用下面这用方式console.log(object[ame]); 数组类型 即便中间删除一些数据，编号依然是从0~n，中间不会有空缺 数组里面的数据可以是不同类型 12345//声明var arr = [&apos;a&apos;,23,&quot;hellw&quot;,true];//调用console.log(arr[2]); 运算符 基本的+、-、*、/、不想说，懒癌发作。 JS的连接运算符是：”+” 1234567&lt;script&gt; console.log(2+3); //输出 5 console.log(&quot;hellow&quot;+&quot;&quot;+&quot;world&quot;); //输出 hello world console.log(2+3+5+&quot;hello&quot;+6+8); //输出 10hello68，一旦碰到非法数字，后面的一律理解为拼接&lt;/script&gt; 逻辑运算符：不是单纯的返回true或false，而是返回最早能判断表达式整体结果的值 12345678910&lt;script&gt; var a = false; var b = 6; var c = a || b; console.log(c); //输出 6 var d = true； var e = a || b || d; console.log(d); //输出 6&lt;/script&gt; 控制结构1234567891011121314151617//遍历数组&lt;script&gt; var arr = [&quot;赵&quot;,&quot;钱&quot;,&quot;孙&quot;,&quot;李&quot;]; for(var i=0; i++; i&lt;arr.length)&#123; console.log(arr[i]); &#125;&lt;/script&gt;//遍历对象&lt;script&gt; var obj = &#123;name:&quot;lisi&quot;,age:28,height:180&#125;; for(var k in obj)&#123; console.log(k); //正确 console.log(obj.k); //错误 console.log(obj[k]); //正确 &#125;&lt;/script&gt; 对象操作12345&lt;script&gt; var str = &quot;helloworld&quot;; console.log(str.length); //输出 10 console.log(str.substr(2,3)); //输出 llo&lt;/script&gt; 在JS中，如果调用属性和方法，会自动将变量转化为对象，这是JS中的重要思想indexOf()函数 1234567&lt;script&gt; var str = &quot;helloworld&quot;; console.log(str.indexOf(&quot;he&quot;)); //找到了，返回值为0，为false console.log(str.indexOf(&quot;dede&quot;)); //找不到，返回值为-1，为true //这就比较尴尬了，所以要进行如下处理 console.log(str.indexOf(&quot;he&quot;) &gt;= 0 ？ &quot;find&quot; : &quot;not find&quot;);&lt;/script&gt; JS内置对象123456789&lt;script&gt; var dt = new Date(); //想调用时间函数，需要先实例化 console.log(dt.getFullYear());&lt;/script&gt;//但是Math是个例外，不需要实例化，就可以直接使用&lt;script&gt; console.log(Math.floor(2.3)); //调用的其实是Math类的静态方法&lt;/script&gt; 浏览器window对象 [即BOM对象] window对象是浏览器宿主对象，简单说就是用户看到的浏览器窗口。其本身和JS语言没有关系 window对象又包含很多子对象 location //控制地址栏 screen //控制屏幕 history //控制浏览器历史记录 document //控制页面文本，这就是DOM对象 作用域12345678910111213141516171819202122232425&lt;script&gt; function t1()&#123; var str = &quot;china&quot;; function t2()&#123; var str = &quot;japan&quot;; //输出结果为 japan,如果将本行注释掉，输出结果为 china alert(str); &#125; t2(); &#125; t1();&lt;/script&gt;&lt;script&gt; window.str = &quot;union&quot;; function t1()&#123; function t2()&#123; str = &quot;japan&quot;; alert(str); &#125; t2(); &#125; t1(); alert(window.str); //输出结果为 japan japan&lt;/script&gt; 如果一个变量在自身作用域内没有赋值，那么它会一直向上级查找，如多查到window层面[全局]还没有，就返回undefined 变量前不加 var，就是赋值，比如第二个例子，第一次打印的是t2()的japan,但是由于其赋值运算污染了全局变量的值，所以，第二次也是japan 找对象123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;关键是找对象&lt;/h1&gt; &lt;div id=&quot;test1&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;test2&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; value=&quot;poly&quot;&gt; &lt;script&gt; //用ID来查询，返回值是&quot;对象&quot; console.log(document.getElementById(&apos;test1&apos;)); //用标签来查询，返回值是&quot;对象的集合&quot;，即使只找到一个对象，也包装成对象集合返回 var ps = document.getElementsByTagName(&apos;p&apos;); ps[1].style.background = &apos;green&apos;; //对于表单元素，可以用name来查询，返回值是对象集合 alert(document.getElementsByName(&apos;username&apos;)[0].value); document.getElementsByName(&apos;username&apos;)[0].value = &apos;lucy&apos;; //按照类名查找，返回值是&quot;对象的集合&quot; document.getElementsByClassName(&apos;test2&apos;)[0].style.background = &apos;gray&apos;; //查找子节点或父节点 alert(document.getElementById(&apos;test1&apos;).childNodes.length); //输出 7,标准属性,一般不用 alert(document.getElementById(&apos;test1&apos;).children.length); //输出 3 /* children非标准属性，但兼容性好，它不包含空白节点 */ document/getElementsByTagName(&apos;p&apos;)[2].parentNode.style.border = &apos;1px solid green&apos;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 操作对象的属性1&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; style=&quot;width: 300px; height: 300px;&quot;&gt; 普通属性可以通过：[ 对象.标签属性 ] 访问 CSS属性通过：[ 对象.style.属性 ] 访问，这种方式只适用于将css直接写在HTML标签内的属性 对类名进行操作，需要使用下面这种方式：[ 对象.className ] 如果CSS带有横线，如border-top-style，则把横线去除，并且横线后的第一和字母大写，如 [ 对象.borderTopStyle ] 获取对象在内存中计算后的样式上一节中，obj.style只能取得“内联style”的值，对于中的CSS属性值，则无能为力，我们可以用obj.currentStyle和window.getConputeStyle来获取。 注意：只有IE和Opera支持使用currentStyle获取HTML Element的计算后的样式，其他浏览器中不支持，标准浏览器中使用getComputeStyle，IE9及以上也支持getComputeStyle window.getComputeStyle(obj,伪元素) 参数说明： 第一个参数为要获取计算后的样式的目标元素 第二个参数为期望的伪元素，如”:after”、”:first-letter”等，一般设为null 考虑兼容性，封装函数12345&lt;script&gt; function getStyle()&#123; return e1.getcurrentStyle ? e1.getcurrentStyle[attr] : getComputeStyle(e1,null)[atttr]; &#125;&lt;/script&gt; 注意：这2个方法获取的对象是只读的，要该样式，还得靠obj.style 删除节点 找到对象 找到它的父对象parentObj parentObj.removeChild(子对象); 1234567891011121314151617//删除最后一个li&lt;input type=&quot;button&quot; value=&quot;删除最后一个li&quot; onclick=&quot;del();&quot;&gt;&lt;ul&gt; &lt;li&gt;春&lt;/li&gt; &lt;li&gt;夏&lt;/li&gt; &lt;li&gt;秋&lt;/li&gt; &lt;li&gt;冬&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; function del()&#123; var lis = document.getElementsByTagName(li); var lastli = lis[lis.length-1]; lastli.parentNode.removeChild(lastli); &#125;&lt;/script&gt; 创建节点 创建对象 找到父对象parentObj parentObj.addChild(对象); 12345678910111213141516//添加一个li&lt;input type=&quot;button&quot; value=&quot;删除最后一个li&quot; onclick=&quot;add();&quot;&gt;&lt;ul&gt; &lt;li&gt;春&lt;/li&gt; &lt;li&gt;夏&lt;/li&gt; &lt;li&gt;秋&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; function add()&#123; var li = document.createElement(&apos;li&apos;); //创建节点 var text = document.createTextNode(&apos;冬&apos;); //创建一个文本节点 li.appendChild(text); //向节点添加最后一个子节点。 document.getElementsByTagName(&apos;ul&apos;)[0].appendChild(&apos;li&apos;); &#125;&lt;/script&gt; 暴力操作节点innerHTML：代表节点内的内容，能读能写，不是一个W3C规定的标准对象属性，但是，各浏览器支持的很好。 1234567891011121314&lt;input type=&quot;button&quot; value=&quot;添加春夏秋&quot; onclick=&quot;add3();&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;添加冬&quot; onclick=&quot;add1();&quot;&gt;&lt;script&gt; function add3()&#123; var ul = document.getElementsByTagName(&apos;ul&apos;)[0]; ui.innerHTML = &quot;&lt;li&gt;春&lt;/li&gt;&lt;li&gt;夏&lt;/li&gt;&lt;li&gt;秋&lt;/li&gt;&quot;; &#125; function add1()&#123; var ul = document.getElementsByTagName(&apos;ul&apos;)[0]; ui.innerHTML += &quot;&lt;li&gt;冬&lt;/li&gt;&quot;; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Frameset搭建框架集]]></title>
    <url>%2F2015%2F03%2F18%2FFrameset%E6%90%AD%E5%BB%BA%E6%A1%86%E6%9E%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[制作导航框架123456789&lt;html&gt; &lt;frameset rows=&quot;25%,75%&quot;&gt; (上下分开界面) &lt;frame src=&quot;top.html&quot;&gt; &lt;!--这是头部top&gt; &lt;frameset cols=&quot;25%,75%&quot;&gt; (左右分开界面) &lt;frame src=&quot;left.html&quot;&gt;&lt;!--左边的导航栏&gt; &lt;frame src=&quot;right.html&quot; name=&quot;mainframe&quot;&gt; &lt;!--右边的主框架,默认进入的首界面，放在left页面链接的第一个--&gt; &lt;/frameset&gt;&lt;/html&gt; 制作导航页面（注意target属性）1234567&lt;html&gt; &lt;!--这个是left页面--&gt; &lt;body&gt; &lt;a href=&quot;right.html&quot; target=&quot;mainframe&quot;&gt;跳转到Test.html&lt;/a&gt;&lt;/br&gt; &lt;a href=&quot;1.html&quot; target=&quot;mainframe&quot;&gt;跳转到Test1.html&lt;/a&gt;&lt;/br&gt; &lt;a href=&quot;2.html&quot; target=&quot;mainframe&quot;&gt;跳转到Test2.html&lt;/a&gt;&lt;/br&gt; &lt;/body&gt;&lt;/html&gt; frameset和body不可嵌套使用，并不是所有的浏览器都支持frameset，用frameset就不能允许body存在 如果不想让框架拖动，在 标签内嵌入noresize=”noresize” 1如:&lt;frame noresize=&quot;noresize&quot;&gt; 的border属性可以去除其边框]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动与清除浮动]]></title>
    <url>%2F2015%2F03%2F12%2F%E6%B5%AE%E5%8A%A8%E4%B8%8E%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[元素浮动首先写两个普通div元素12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #div_1&#123; width: 400px; height: 200px; background-color: yellow; &#125; #div_2&#123; width: 400px; height: 200px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div_1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;div_2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下 然后将div_1赋予一个左浮动，修改其样式如下123456#div_1&#123; floa: left; width: 400px; height: 200px; background-color: yellow; &#125; 运行结果如下 这是因为div_1元素设置浮动以后，脱离了当前文本流并处在普通元素之上，而div_2元素就会被移动并被其遮挡 元素设置浮动后，必须要设置宽度 普通元素具有高度[3D]，浮动后元素没有高度[2D]。 元素实际位置关系如下图所示 清除浮动现在如果我们想保持div_1元素的float属性保持不变，但又不想div_2元素被遮盖，那么我们就需要清除浮动带来的影响123456#div_2&#123; width: 400px; height: 200px; background-color: yellow; clear: both;&#125; 运行结果如下 最后运行结果虽然与两个普通div一样，但是他们是存在很大区别的 清除浮动的属性要加在受影响的元素上]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Margin重叠现象]]></title>
    <url>%2F2015%2F03%2F10%2Fmargin%E9%87%8D%E5%8F%A0%E7%8E%B0%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[边界叠加是一个相当简单的概念。但是，在实践中对网页进行布局时，它会造成许多混淆。简单地说，当两个垂直边界相遇时，它们将形成一个边界。这个边界的高度等于两个发生叠加的边界的高度中的较大者。 兄弟元素之间发生叠加当一个元素出现在另一个元素上面时，第一个元素的底边界与第二个元素的顶边界发生叠加，见图： 父子元素之间发生叠加子级的上下margin会与父级上下margin重叠，以数值大的为准，而不会相加 解决方案兄弟元素之间发生叠加 float浮动 inline-block 父子元素之间发生叠加 父级加以下三个属性的任意一个： overflow:hidden padding border 子级加position:absolute]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
